<div ref:completionContainer class="completion-container" style="display:{{open?'block':'none'}}" >
    <div ref:completion class="completion"/>
    <div ref:docstring class="docstring">{{docstring}}</div>
</div>

<style>
    .completion-container {
        position: absolute;
        z-index: 99;
        box-shadow: var(--default-shadow);
        height: 14rem;
        width: 50rem;
    }
    
    .completion {
        background: var(--main-bg-color);
        color: var(--basic-monospace-font-color);
        height: 14rem;
        width: 24rem;
        z-index: 100;
        position: absolute;
        border-radius: var(--default-radius);
        font-family: var(--basic-monospace-font-family);
        font-size: var(--basic-monospace-font-size);
        line-height: 2rem;

        overflow-x: scroll;
        cursor: default;
        user-select: none;
        -webkit-user-select: none;
    }

    .docstring {
        background: var(--panel-color);
        z-index: 99;
        position: absolute;
        left: 22rem;
        padding-left: 2rem;
        border-radius: var(--default-radius);
        height: 14rem;
        width: 26rem;
    }

</style>


<script>
    import g from '../../lib/Globals'
    import CompletionRow from './CompletionRow.html'
    import EventDispatcherFactory from '../../LayeredKeyboardControl/EventDispatcherFactory'

    export default {
        components: {},
        oncreate() {
            this.observe('open', open => {
                if (open) g.pushFocus(this)
                else g.popFocus(this)
            })
            const completion = this.refs.completion
            this.onClickHandler = (event) => {
                this.set({
                    selectedCompletionRow: event.path[0]
                })
                this.enter()
            }
            this.completionRows = []
            this.completionRowShortcuts = new Array(9)

            // keep row number of visible rows 1 to 7
            let lastFVI = 999
            const scrollHandler = () => {
                const rowHeight = this.completionRows[0].refs.completionRow.clientHeight
                let firstVisibleIndex = Math.floor(completion.scrollTop / rowHeight)
                if (firstVisibleIndex < 0)
                    firstVisibleIndex = 0
                if (firstVisibleIndex > this.completionRows.length)
                    firstVisibleIndex = this.completionRows.length - 1
                if (lastFVI === firstVisibleIndex) return

                let lastVisibleIndex = firstVisibleIndex + 8
                if (lastVisibleIndex > this.completionRows.length)
                    lastVisibleIndex = this.completionRows.length
                for (let i = firstVisibleIndex; i < lastVisibleIndex; i++) {
                    const rowNumber = i - firstVisibleIndex + 1
                    this.completionRows[i].set({
                        rowNumber
                    })
                    this.completionRowShortcuts[rowNumber] = this.completionRows[i]
                }
                lastFVI = firstVisibleIndex
            }
            completion.addEventListener('scroll', scrollHandler, {
                passive: true
            })

            this.observe('rows', rows => {
                for (const row of this.completionRows)
                    row.destroy()
                this.completionRows.length = 0
                if (rows.length === 0) return
                for (const [i, row] of rows.entries()) {
                    row.index = i
                    this.completionRows.push(new CompletionRow({
                        target: completion,
                        data: row
                    }))
                }
                lastFVI = 999
                this.set({
                    selectedCompletionRow: this.completionRows[0]
                })
                this.completionRows.length && setTimeout(scrollHandler) // must defer, or we cannot get row height
            })

            this.observe('selectedCompletionRow', (newValue, oldValue) => {
                if (oldValue) oldValue.set({
                    selected: false
                })
                if (newValue) newValue.set({
                    selected: true
                })
            })

            this.keyEventHandler = EventDispatcherFactory({
                target: this,
                extraKeyHandler(event, target) {
                    if (/[.,()[\]:+\-*/|&^~%@><!]/.test(event.key))
                        target.enter()
                    else if (/[=[\](){}]/.test(event.key))
                        target.set({
                            open: false
                        })
                    return true
                }
            })
        },
        data() {
            return {
                open: false,
                passive: false,
                rows: [],
                selectedCompletionRow: undefined,
                docstring: '',
            }
        },
        methods: {
            bindReferences(editor) {
                this.editor = editor
                this.cm = editor.cm
                this.predictor = editor.predictor
            },
            shouldDisplayCompletionRow(row) {
                if (this.get('passive') && row.c.length < 3) return false
                return row.sortScore > 0
            },
            setCompletions() {
                const filteredCompletion = this.predictor.currentCompletions.filter(
                    this.shouldDisplayCompletionRow, this)
                if (filteredCompletion.length) {
                    this.set({
                        rows: filteredCompletion,
                        open: true
                    })
                } else this.set({
                    open: false
                })
            },
            repositionCompletionWindow() {
                const editorElement = this.editor.refs.codeEditor
                const completionElement = this.refs.completionContainer

                const rem = parseFloat(getComputedStyle(document.documentElement).fontSize)
                const coords = this.cm.charCoords(this.predictor.firstTriggeredCharPos, 'window')
                const charHeight = coords.bottom - coords.top

                const editorArea = editorElement.getBoundingClientRect()
                const completionArea = completionElement.getBoundingClientRect()
                const completionHeight = completionArea.bottom - completionArea.top

                let x = coords.left - editorArea.left - 3 * rem
                let y = coords.bottom - editorArea.top + 1.3 * charHeight
                if (y + completionHeight > editorArea.bottom) {
                    y = coords.top - completionHeight - 1.3 * charHeight
                }
                completionElement.style.left = `${x}px`
                completionElement.style.top = `${y}px`
            },
            enter(rowNumber) {
                if (!this.get('open')) return console.error('closed')

                const completion = rowNumber ? this.completionRowShortcuts[rowNumber] : this.get('selectedCompletionRow')
                if (!completion) return console.error('no selected completion')

                const type = completion.get('t')
                this.set({
                    open: false
                })
                if (type === 'instruction') return

                let text = completion.get('c')
                if (type === 'keyword' || type === 'module') text += ' '

                this.cm.doc.replaceRange(
                    text,
                    this.predictor.firstTriggeredCharPos,
                    this.cm.doc.getCursor(),
                    '+completion'
                )
                this.cm.focus()
            },
            move(nRows) {
                const currentIndex = this.get('selectedCompletionRow').get('index')
                const length = this.completionRows.length

                let targetIndex = currentIndex + nRows
                if (targetIndex >= length) targetIndex = length - 1
                else if (targetIndex < 0) targetIndex = 0

                const targetRow = this.completionRows[targetIndex]
                this.set({
                    selectedCompletionRow: targetRow
                })
                targetRow.refs.completionRow.scrollIntoViewIfNeeded(false)
            }
        }
    }

</script>
