<div ref:container id="docs" class="container {active?'':'gone'}">
    <div id="function-doc-container" class="{completionDoc?'':'expand'}">
        {#if functionDoc}
        <div ref:functionDoc id="function-doc" class="{functionDocType==='html'?'':'text-docstring'}">
            {#if functionDocType==='html'} {@html functionDoc} {:else} {functionDoc} {/if}
        </div>
        {/if}
    </div>
    <div ref:splitBar id="split-bar-doc" class="split-bar {completionDoc?'':'gone'}"></div>
    <div class="mask {completionDoc?'':'gone'}"></div>
    <div id="completion-doc-container" class="{completionDoc?'':'gone'}">
        {#if completionDoc}
        <div ref:completionDoc id="completion-doc" class="{completionDocType==='html'?'':'text-docstring'}">
            {#if completionDocType==='html'} {@html completionDoc} {:else} {completionDoc} {/if} </div>
        {/if}
    </div>
</div>

<style>
    .container {
        position: absolute;
        height: calc(100% - var(--indicator-height) - .1rem);
        width: 100%;
    }

    .split-bar {
        position: absolute;
        top: calc(var(--function-doc-height) - .4rem);
        left: 0;
        height: .9rem;
        width: 100%;
        cursor: row-resize;
        z-index: 3;
    }

    .mask {
        position: absolute;
        top: calc(var(--function-doc-height) - .4rem);
        z-index: 2;
        width: 100%;
        background: linear-gradient(transparent 0%, var(--panel-color) 45%, var(--gray3) 45%, var(--gray3) 55%, var(--panel-color) 55%, transparent 100%);
        height: .9rem;
    }

    .split-bar:hover {
        background: var(--panel-delimiter-hover-color);
        background: linear-gradient(to bottom,
        transparent 30%, var(--panel-delimiter-hover-color) 30%,
        var(--panel-delimiter-hover-color) 70%,
        transparent 70%);
    }

    #function-doc-container {
        position: absolute;
        height: var(--function-doc-height);
        width: 100%;
        border-bottom: var(--panel-border);
        overflow-y: scroll;
    }

    #function-doc-container.expand {
        height: calc(100% - var(--tab-bar-height));
        border-bottom: none;
    }

    #completion-doc-container {
        position: absolute;
        top: var(--function-doc-height);
        height: calc(100% - var(--function-doc-height) - var(--tab-bar-height));
        width: 100%;
        overflow-y: scroll;
    }

    #function-doc {
        margin: .5rem;
        margin-bottom: 1rem;
    }

    #completion-doc {
        margin: .5rem;
        margin-bottom: 1rem;
    }

    .text-docstring {
        white-space: pre-wrap;
        font-family: var(--basic-monospace-font-family);
    }

    :global(.highlight-parameter) {
        background: var(--gray1);
    }

</style>


<script>
    import g from '../lib/Globals'
    import { initializeTabView, onIdle, Pos, isStringOrComment, inParentheses } from '../lib/Utils'

    let lastTokenStart = { line: 0, ch: 0 }
    const matchingForward = { '(': ')', '[': ']', '{': '}' }
    const matchingBackward = { ')': '(', ']': '[', '}': '{' }

    function findParameterName(cm, char, pos) {
        if (char === '=') {
            const token = cm.getTokenAt(pos)
            if (token.type === 'variable')
                return token.string
        } else if (char === ',' && !isStringOrComment(cm, Pos(pos.line, pos.ch + 1))) {
            return false
        } else if (matchingForward[char]) {
            return false
        }
    }

    export default {
        components: {},
        oncreate() {
            g.docs = this
            initializeTabView(this, 'Documentation', 'fas fa-book l-red')
            onIdle(() => {
                this.refs.splitBar.onmousedown = e => {
                    e.preventDefault()
                    document.onmousemove = e => {
                        const height = (e.pageY - this.refs.container.getBoundingClientRect().y) + 'px'
                        requestAnimationFrame(() => {
                            document.documentElement.style.setProperty('--function-doc-height', height)
                        })
                    }
                }
            })
        },
        data() {
            return {
                active: false,
                completionDoc: null,
                completionDocType: 'html',
                functionDoc: null,
                functionDocType: 'html',
                functionDocTriggeredFile: '',
                functionDocTriggeredPos: null,
            }
        },
        methods: {
            getFunctionDocIfNeeded(cm, editor) {
                if (cm.somethingSelected()) return

                const cursor = cm.getCursor()
                const token = cm.getTokenAt(cursor)
                // don't request function doc if the cursor is moving on the same token
                if (token.start === lastTokenStart.ch && cursor.line === lastTokenStart.line) return
                lastTokenStart.line = cursor.line
                lastTokenStart.ch = token.start

                // don't request function doc if the cursor is moving within the same braces
                const pos = inParentheses(cm, cursor)

                const { filePath } = editor.get()
                const { functionDocTriggeredFile, functionDocTriggeredPos } = this.get()
                if (functionDocTriggeredPos && pos &&
                    functionDocTriggeredPos.ch === pos.ch &&
                    functionDocTriggeredPos.line === pos.line &&
                    functionDocTriggeredFile === filePath) {
                    this.highlightActiveParameter(cm, cursor)
                    return
                }
                this.set({ functionDocTriggeredPos: pos, functionDocTriggeredFile: filePath })

                editor.ws.send({
                    cmd: 'getFunctionDocumentation',
                    line: cursor.line,
                    ch: cursor.ch,
                    text: cm.getLine(cursor.line)
                })
                return true

            },
            highlightActiveParameter(cm, cursor) {
                if (!cursor) cursor = cm.getCursor()
                let activeParameter = this.getActiveParameter(cm, cursor)
                const oldHighlights = document.querySelectorAll('#function-doc dt.highlight-parameter')
                for (const node of oldHighlights)
                    node.classList.remove('highlight-parameter')
                if (activeParameter === false) return

                if (Number.isInteger(activeParameter)) {

                    try {
                        const { functionDoc, functionDocType } = this.get()
                        let functionSignature
                        if (functionDocType === 'html') {
                            functionSignature = document.querySelector('#function-doc p').innerText
                        } else {
                            functionSignature = functionDoc.substring(0, functionDoc.indexOf('\n\n'))
                        }
                        activeParameter = this.getParameterFromFunctionSignature(functionSignature, activeParameter)
                    } catch (e) {
                        console.error(e)
                        return
                    }
                }
                for (const node of document.querySelectorAll('#function-doc dt')) {
                    if (node.innerText.startsWith(activeParameter)) {
                        node.scrollIntoView(true)
                        node.classList.add('highlight-parameter')
                        break
                    }
                }


            },
            getParameterFromFunctionSignature(signature, index) {
                const stack = []
                const length = signature.length
                let stackTop
                for (let i = 0; i < length; i++) {
                    const char = signature.charAt(i)
                    const opening = matchingForward[char]
                    if (opening) {
                        stack.push(opening)
                        stackTop = opening
                        if (signature.substr(i + 1, 5) === 'self,')
                            i += 6
                        continue
                    }
                    if (char === stackTop) {
                        stackTop = stack.pop()
                        continue
                    }
                    if (stack.length === 1) {
                        if (char === ',') {
                            index--
                            i++
                        }
                        if (index === 0) {
                            let end = signature.indexOf(',', i)
                            let result = signature.substring(i, end)
                            end = result.indexOf('=')
                            if (end > 0)
                                result = result.substring(0, end)
                            end = result.indexOf(':')
                            if (end > 0)
                                result = result.substring(0, end)
                            return result.trim()
                        }
                    }
                }
            },
            getActiveParameter(cm, cursor) {
                const pos = Pos(cursor)
                let kwarg = this.scanInSameLevelOfBraces(cm, cursor, findParameterName)
                if (!kwarg) {
                    const token = cm.getTokenAt(pos)
                    if (token.type === 'variable') {
                        pos.ch = token.end + 1
                        const nextToken = cm.getTokenAt(pos)
                        if (nextToken.string === '=')
                            kwarg = token.string
                    }
                }
                if (kwarg)
                    return kwarg

                let index = 0
                let findParameterIndex = (cm, char, pos) => {
                    if (!isStringOrComment(cm, Pos(pos.line, pos.ch + 1))) {
                        if (char === '(') {
                            const token = cm.getTokenAt(pos)
                            if (token.type === 'function' || token.type === 'builtin')
                                return index
                            else index = 0
                        } else if (char === ',') {
                            ++index
                        } else if (char === '{' || char === '[') {
                            index = 0
                        }
                    }

                }
                let argIndex = this.scanInSameLevelOfBraces(cm, cursor, findParameterIndex)
                return argIndex
            },
            /**
             * Backward scan in braces
             * @param   {object}   cm       CodeMirror instance
             * @param   {object}   cursor   {line, ch}
             * @param   {function} callback (cm, char, pos) => {false|string} to run for every character
             * @returns {object}   returns what the callback returns, or false
             */
            scanInSameLevelOfBraces(cm, cursor, callback) {
                const stack = []
                let stackTop
                const pos = Pos(0, 0)
                for (let line = cursor.line; line >= Math.max(0, cursor.line - 10); line--) {
                    const lineContent = cm.getLine(line)
                    pos.line = line
                    if (!lineContent) continue
                    let ch = lineContent.length - 1,
                        end = -1
                    if (line === cursor.line) ch = cursor.ch - 1

                    for (; ch > end; ch--) {
                        pos.ch = ch
                        const char = lineContent.charAt(ch)
                        const opening = matchingBackward[char]
                        if (opening) {
                            if (isStringOrComment(cm, pos)) {
                                const token = cm.getTokenAt(pos)
                                ch = token.start
                                continue
                            }
                            stack.push(opening)
                            stackTop = opening
                            continue
                        }
                        if (char === stackTop) {
                            if (isStringOrComment(cm, pos)) {
                                const token = cm.getTokenAt(pos)
                                ch = token.start
                                continue
                            }
                            stackTop = stack.pop()
                            continue
                        }
                        if (stack.length === 0) {
                            const result = callback(cm, char, pos)
                            if (result !== undefined) return result
                        }
                    }
                }
                return false
            },
        }
    }

</script>
