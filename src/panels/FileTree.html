<div ref:fileTree class="file-tree">
    <div class="container" ref:children>
        {{#each dirs as i @uid}}
        <FileTreeNode name={{i.name}} parent={{self}} isDir></FileTreeNode>
        {{/each}} {{#each files as i @uid}}
        <FileTreeNode name={{i.name}} parent={{self}}></FileTreeNode>
        {{/each}}
    </div>
</div>

<style>
    .file-tree {
        width: 100%;
        height: calc(100% - .8rem);
        padding: .4rem 0;
        color: var(--basic-ui-font-color);
        font-family: var(--basic-ui-font-family);
        font-size: var(--basic-ui-font-size);
        -webkit-font-smoothing: subpixel-antialiased;
        user-select: none;
        -webkit-user-select: none;
        overflow-x: scroll;
    }

    .container {
        min-width: 100%;
        display: inline-block;
    }

</style>


<script>
    import g from '../lib/Globals'
    import WSClient from '../lib/WSClient'
    import FileTreeNode from './FileTreeNode.html'
    import EventDispatcherFactory from '../LayeredKeyboardControl/EventDispatcherFactory'
    import {
        binarySearch
    } from '../lib/Utils'

    export default {
        components: {
            FileTreeNode
        },
        oncreate() {
            this.children = {}
            g.fileTree = this
            this.set({
                self: this,
            })
            this.ws = new WSClient('ws://127.0.0.1:3179/fileTree')

            const sortAndAddUid = arr => arr.sort().map(i => {
                return {
                    name: i,
                    uid: g.uid
                }
            })
            this.ws.addHandler('openFolder-ok', data => {
                this.getNode(data.path).set({
                    dirs: sortAndAddUid(data.dirs),
                    files: sortAndAddUid(data.files)
                })
                if (this.scheduledMoveToChildrenAfterOpening)
                    this.moveToChildrenAfterOpening()
            })

            const sortChildren = (node, type) => {
                node.set({
                    type: node.get(type).sort((a, b) => a.name > b.name)
                })
            }
            const renamingEventHandler = data => {
                // change file tree names
                const node = this.getNode(data.path)
                const parent = node.get('parent')
                const oldName = data.path[data.path.length - 1]
                const target = data.cmd === 'event-FileRenamed' ? 'files' : 'dirs'
                const destPath = [...data.path]
                destPath[destPath.length - 1] = data.newName
                node.set({
                    name: data.newName
                })
                // change paths to opened files
                parent.get(target).find(x => x.name == oldName).name = data.newName
                sortChildren(parent, target)
                if (target === 'files') {
                    const editor = g.panelMiddle.getEditor(data.path)
                    editor && editor.set({
                        fileName: data.newName
                    })
                }
                g.panelMiddle.renameDir(destPath, data.path)
            }
            this.ws.addHandler('event-FileRenamed', renamingEventHandler)
            this.ws.addHandler('event-DirRenamed', renamingEventHandler)
            this.ws.addHandler('rename-ok', data => {
                g.notificationBar.show('success', `"<b>${data.oldName}</b>" has been renamed to "<b>${data.newName}</b>"`)
            })
            this.ws.addHandler('rename-failed', data => {
                g.notificationBar.show('warning', `Failed to rename "<b>${data.oldName}</b>". ${data.reason}.`)
            })

            this.ws.addHandler('newfile-ok', data => {
                g.notificationBar.show('success', `"new file: <b>${data.newfileName}</b>"`)
            })
            this.ws.addHandler('newfile-failed', data => {
                g.notificationBar.show('warning', `"Failed to new file: <b>${data.newfileName}</b>". ${data.reason}.`)
            })

            const handlerFactory = (target, eventType) => {
                return data => {
                    const node = this.getNode(data.path.slice(0, -1))
                    const arr = node.get(target)
                    const name = data.path[data.path.length - 1]
                    const position = binarySearch(arr, name)
                    if (eventType === 'created')
                        arr.splice(position, 0, {
                            name,
                            uid: g.uid
                        })
                    else arr.splice(position, 1)
                    if (target === 'files')
                        node.set({
                            files: arr
                        })
                    else
                        node.set({
                            dirs: arr
                        })
                }
            }
            this.ws.addHandler('event-FileCreated', handlerFactory('files', 'created'))
            this.ws.addHandler('event-DirCreated', handlerFactory('dirs', 'created'))
            this.ws.addHandler('event-FileDeleted', handlerFactory('files', 'deleted'))
            this.ws.addHandler('event-DirDeleted', handlerFactory('dirs', 'deleted'))

            this.ws.connect(() => {
                this.ws.send({
                    cmd: 'openFolder',
                    path: this.get('root'),
                    isRoot: true
                })
            })

            const target = this
            this.keyEventHandler = {
                handleKeyEvent(event) {
                    switch (event.key) {
                        case 'ArrowDown':
                            target.moveToSiblin(1)
                            break
                        case 'ArrowUp':
                            target.moveToSiblin(-1)
                            break
                        case 'ArrowLeft':
                            target.moveToParent()
                            break
                        case 'ArrowRight':
                            target.moveToChildren()
                            break
                        case ' ':
                        case 'Enter':
                            target.enter()
                            break
                        default:
                            return true // if not handled
                    }
                    return false
                },
                handleCommand(command) {
                    switch (command) {
                        case 'down':
                            target.moveToSiblin(1)
                            break
                        case 'up':
                            target.moveToSiblin(-1)
                            break
                        case 'down5X':
                            target.moveToSiblin(5)
                            break
                        case 'up5X':
                            target.moveToSiblin(-5)
                            break
                        case 'left':
                            target.moveToParent()
                            break
                        case 'right':
                            target.moveToChildren()
                            break
                        case 'end':
                            target.move(999999)
                            break
                        case 'home':
                            target.move(-999999)
                            break
                        case 'commit':
                            target.contextMenu()
                            break
                        case 'scrollUp':
                            target.scroll(-0.1)
                            break
                        case 'scrollDown':
                            target.scroll(0.1)
                            break
                        default:
                            return true // if not handled
                    }
                    return false
                }
            }
        },
        data() {
            return {
                root: '.',
                dirs: [],
                files: [],
                self: this
            }
        },
        methods: {
            getNode(path) {
                let node = this
                for (const i of path) {
                    node = node.children[i]
                }
                return node
            },
            moveToSiblin(n) {
                const currentFocus = g.focus
                if (currentFocus.constructor.name !== 'FileTreeNode') return
                let currentNode = currentFocus
                for (let i = Math.abs(n); i > 0; i--) {
                    const nextNode = currentNode.nextNode(n)
                    if (!nextNode) break
                    currentNode = nextNode
                }
                if (!currentNode && currentNode === currentFocus) return
                if (!currentNode.get('selected')) currentNode.onClick()
                currentNode.refs.row.scrollIntoViewIfNeeded(false)
            },
            moveToChildren() {
                const currentNode = g.focus
                if (currentNode.constructor.name !== 'FileTreeNode') return
                if (!currentNode.get('isDir')) return
                if (currentNode.get('open')) {
                    this.moveToChildrenAfterOpening()
                    return
                }
                currentNode.onDoubleClick()
                this.scheduledMoveToChildrenAfterOpening = true
            },
            moveToChildrenAfterOpening() {
                const currentNode = g.focus
                const dirs = currentNode.get('dirs')
                const files = currentNode.get('files')
                let firstChildName = dirs.length ? dirs[0].name : (files.length ? files[0].name : null)
                if (!firstChildName) return
                const firstChildNode = currentNode.children[firstChildName]
                firstChildNode.onClick()
                firstChildNode.refs.row.scrollIntoViewIfNeeded(false)
                this.scheduledMoveToChildrenAfterOpening = false
            },
            moveToParent() {
                const currentNode = g.focus
                if (currentNode.constructor.name !== 'FileTreeNode') return
                const parent = currentNode.get('parent')
                if (!parent) return
                parent.onClick()
                parent.refs.row.scrollIntoViewIfNeeded(false)
            },
            enter() {
                const currentNode = g.focus
                if (currentNode.constructor.name !== 'FileTreeNode') return
                currentNode.onDoubleClick()
            },
            contextMenu() {
                const focus = g.focus
                if (focus.constructor.name !== 'FileTreeNode') return

                const x = this.refs.fileTree.getBoundingClientRect().right
                const y = focus.refs.row.getBoundingClientRect().top
                focus.onContextMenu({
                    clientX: x - 10,
                    clientY: y + 10,
                    preventDefault() {}
                })
            },
            scroll(amount) {
                window.cancelAnimationFrame(this.currentAnimationId)
                const fileTree = this.refs.fileTree
                const vh = fileTree.getBoundingClientRect().height * amount
                let d = 1.
                const step = () => {
                    fileTree.scrollTop += vh * d
                    if (d > 0.1) {
                        d -= 0.1
                        this.currentAnimationId = window.requestAnimationFrame(step)
                    }
                }
                step()
            }
        }
    }

</script>
