<div bind:this={self} id="panel-middle" class="{focused?'indicator-on':''}">
    <TabBar bind:this={tabBar} on:requestTabClose="{(e) => closeView(e.detail.view)}"></TabBar>
    {#if !focus}
    <div class="placeholder non-selectable">Double click on a file on the file tree to open.</div>
    {/if}
    {#each Object.values(editorProps) as prop, i(prop.uid)}
        <CodeEditor bind:this={editors[prop.pathString]} {...prop} on:active="{(e) => onTabChange(e)}"></CodeEditor>
    {/each}
</div>


<style>
    #panel-middle {
        position: fixed;
        top: var(--toolbar-height);
        height: calc(100% - var(--toolbar-height));
        left: calc(var(--panel-left-width) + 1px);
        width: calc(100% - var(--panel-left-width) - var(--panel-right-width) - 1px);
        box-sizing: border-box;
        z-index: 130;
        /* should be higher than that of PanelRight, or Completion will be blocked */
    }
    
    .placeholder {
        position: absolute;
        top: 45%;
        width: 80%;
        margin: 0 10%;
        text-align: center;
        font-size: var(--ui-font-size-large);
        color: var(--gray5);
        z-index: -100;
    }

</style>

<script>
    import { beforeUpdate, onMount, tick } from 'svelte'
    import isEqual from 'lodash.isequal'

    import g from './lib/Globals'
    import { schedule, nextFrame, joinPath } from './lib/Utils'
    import { onTabChangeFactory } from './lib/UIUtils'
    import { getIconByFileName } from './lib/FileTypeToIcon'
    
    import TabBar from './bars/TabBar.html'
    import CodeEditor from './editor/CodeEditor.html'
    
    const MAX_ACTIVATION_HISTORY = 32

    export let focused = false,
        focus = null,
        tabBar = null
    
    let onTabChange, self, openedFiles, activationHistory, activationHistoryIndex

    onMount(() => {
        onTabChange = onTabChangeFactory(tabBar, editors)
        openedFiles = new Set()
        activationHistory = new Array(MAX_ACTIVATION_HISTORY)
        activationHistoryIndex = 0
        
        nextFrame(() => {
            const activePath = g.projectState.activePanels.middle
            let activated = false
            for (const path of g.projectState.openedFiles) {
                const shouldActivate = isEqual(activePath, path)
                openFile(path, null, shouldActivate)
                activated |= shouldActivate
            }
            if (!activated)
                activateFile(g.projectState.openedFiles[0])
        })
    })

    // [svelte-upgrade warning]
    // beforeUpdate and afterUpdate handlers behave
    // differently to their v2 counterparts
    beforeUpdate(() => {
//        if (!previous) return
//        if (changed.focus) {
//            const { focus } = current
//            if (focus === previous.focus) return
//            if (!focus) g.setFocus([g.panelLeft, g.fileTree])
//            else g.setFocus([this, focus])
//            g.activeEditor = focus
//            g.pathIndicator.set({ path: focus ? focus.get().filePath : null })
//        }
//        if (changed.focused) {
//            const editor = __this.get().focus
//            if (current.focused) {
//                editor && editor.cm && editor.cm.focus()
//            } else
//                editor && editor.cm && editor.cm.getInputField().blur()
//        }
    })
    
    $: g.pathIndicator && g.pathIndicator.$set({ path: focus ? focus.filePath : null })

    export function getEditor(filePath) {
        return editors[joinPath(filePath)]
    }

    export let editorProps = {}
    let editorUid = 0
    export let editors = {}
    
    export async function openFile(filePath, cmReadyCallback, activate = true) {
        let editor = getEditor(filePath)
        if (!editor) {
            const fileName = filePath[filePath.length - 1]
            const pathString = joinPath(filePath)
            editorProps[pathString] = {
                fileName, 
                filePath, 
                pathString,
                uid: editorUid++
            }
            await tick()
            editor = editors[pathString]
            editor.cmReadyCallback = cmReadyCallback
//            __this.openedFiles.add(filePath)
            tabBar.openTab(pathString, fileName, editor, getIconByFileName(fileName), true)
        }
        if (!activate) return
        activateFile(filePath)
        if (cmReadyCallback && editor) cmReadyCallback(editor)
        return editor
    }

    export function activateView(editor) {
        activateFile(editor.filePath)
    }

    export function activateFile(filePath) {
        if (!filePath) return
        const editor = getEditor(filePath)
        if (g.activeEditor === editor) {
            return // already activated
        }
        
        // write to activation history
        if (activationHistory[activationHistoryIndex] != filePath) {
            activationHistoryIndex = (activationHistoryIndex + 1) % MAX_ACTIVATION_HISTORY
            activationHistory[activationHistoryIndex] = filePath
        }
        // activate editor
        g.activeEditor && (g.activeEditor.$set({ active: false }))
        focus = editor
        if (!editor) {
            g.linter.clear()
            return
        }
        editor.$set({ active: true })
        g.activeEditor = editor
        
        g.cursorPosition.$set({ isMakefile: editor.isMakefile })
        schedule(() => {
            g.find.$set({ currentFilePath: filePath })
        })
        
        const cm = editor.cm
        if (!cm) return
        cm.focus()

        schedule(() => { // ~5 ms
            const cursor = cm.getCursor()
            g.cursorPosition.$set(cursor)
            g.docs.getFunctionDocIfNeeded(cm, editor, cursor)
            const { offlineLints, realtimeLints, spellingErrors, outline } = editor
            g.linter.$set({ offlineLints, realtimeLints, spellingErrors })
            g.outline.$set({ outlineItems: outline })
        })
    }

    export function renameDir(newDirPath, oldDirPath) {
        const oldDirPathString = joinPath(oldDirPath)
        for (const oldPathString in editors) {
            if (oldPathString.indexOf(oldDirPathString) !== 0) continue
            const editor = editors[oldPathString]
            editor.$set({
                filePath: [...newDirPath, ...editor.filePath.slice(newDirPath.length)]
            })
        }
    }

    export function closeView(editor) {
        closeFile(editor.filePath)
    }

    export function closeFile(filePath) {
        const editor = getEditor(filePath)
        // if the file has been edited, prompt for saving
        if (!editor.clean) {
            g.prompt.open({
                icon: 'far fa-hdd',
                content: `Do you want to save the changes you made in <em>${editor.fileName}</em> ?`,
                buttons: [{
                    text: 'Don\'t Save',
                    style: 'danger',
                    action: () => {
                        editor.$set({ clean: true })
                        closeFile(filePath)
                    }
                }, {
                    text: 'Cancel',
                    style: 'dismiss',
                }, {
                    text: 'Save',
                    style: 'success',
                    action: () => {
                        editor.save()
                        editor.shouldClose = true
                    }
                }]
            })
            return
        }
        openedFiles.delete(filePath)
        const pathString = joinPath(filePath)
        delete editorProps[pathString]
//        editor.destroy()

        // clear activation history
        for (let i = 0; i < MAX_ACTIVATION_HISTORY; i++)
            if (activationHistory[i] === filePath)
                activationHistory[i] = null
        // activate previous file
        for (let i = activationHistoryIndex; i > activationHistoryIndex - MAX_ACTIVATION_HISTORY; i--) {
            const previouslyActivatedFilePath = activationHistory[i % MAX_ACTIVATION_HISTORY]
            if (previouslyActivatedFilePath && getEditor(previouslyActivatedFilePath)) {
                activateFile(previouslyActivatedFilePath)
                return
            }
        }
        // if history is exhausted, select last opened file
        let lastFile = null
        for (lastFile of openedFiles) ;
        if (lastFile) {
            activateFile(lastFile)
        }
        // if no files opened, clear focus
        focus = null
    }
</script>
