{#if open}
<div bind:this={self} id="context-menu" class="popup" style="top:{y}px; left:{x}px;">
</div>
{/if}


<style>
    #context-menu {
        z-index: 910;
        min-height: 2rem;
        min-width: 3rem;
        overflow-x: hidden;
        padding: .2rem 0;
        vertical-align: middle;
        margin-left: .1rem;
        margin-top: -.5rem;
    }

</style>

<script>
    import { beforeUpdate, onMount } from 'svelte'

    import g from '../lib/Globals'
    import ContextMenuRow from './ContextMenuRow.html'
    import ContextMenuDivider from './ContextMenuDivider.html'
    import EventDispatcherFactory from '../LayeredKeyboardControl/EventDispatcherFactory'
    
    // [svelte-upgrade suggestion]
    // manually refactor all references to __this
    const __this = {
        get: () => ({ open, y, x, items, selectedRow, caller, closable })
    }

    export let open = false,
        x = 0,
        y = 0,
        items = [
            // {
            //     text: '',
            //     callback: () => {}
            // }
        ],
        selectedRow = null,
        caller = null,
        closable = true
    
    let self

    onMount(() => {
        __this.rows = []
        __this.dividers = []
        __this.keyEventHandler = EventDispatcherFactory({
            target: this,
        })
    })

    // [svelte-upgrade warning]
    // beforeUpdate and afterUpdate handlers behave
    // differently to their v2 counterparts
    beforeUpdate(() => {
//        if (!previous) return
//        if (changed.open) {
//            selectedRow = undefined
//            if (current.open) {
//                try {
//                    g.activeEditor.completion.set({ open: false })
//                } catch (e) { /* do nothing */ }
//                g.pushFocus(this)
//            } else {
//                g.popFocus(this)
//            }
//            g.app.set({
//                popup: current.open ? this : null
//            })
//        }
//        if (changed.items) {
//            for (const i of __this.rows)
//                i.destroy()
//            for (const i of __this.dividers)
//                i.destroy()
//            __this.rows.length = 0
//            __this.dividers.length = 0
//            if (!current.items) return
//            requestAnimationFrame(() => { // this.refs.contextMenu might be null if referenced immediately
//                for (const i of current.items) {
//                    if (i.divider) {
//                        const child = new ContextMenuDivider({
//                            target: contextMenu,
//                        })
//                        __this.dividers.push(child)
//                    } else {
//                        const child = new ContextMenuRow({
//                            target: contextMenu,
//                            data: i
//                        })
//                        child.parent = this
//                        __this.rows.push(child)
//                    }
//                }
//            })
//        }
//        if (changed.selectedRow) {
//            if (previous.selectedRow) previous.selectedRow.set({
//                selected: false
//            })
//            if (current.selectedRow) current.selectedRow.set({
//                selected: true
//            })
//        }
    })

    // [svelte-upgrade suggestion]
    // review these functions and remove unnecessary 'export' keywords
    export function move(nRows) {
        const currentIndex = __this.rows.indexOf(__this.get().selectedRow)
        const length = __this.rows.length

        let targetIndex = currentIndex + nRows
        if (currentIndex === -1 && nRows < 0) targetIndex = length - 1
        else if (targetIndex >= length) targetIndex = length - 1
        else if (targetIndex < 0) targetIndex = 0

        const targetRow = __this.rows[targetIndex]
        selectedRow = targetRow
    }

    export function enter(rowNumber) {
        const row = rowNumber ? __this.rows[rowNumber - 1] : __this.get().selectedRow
        if (row) row.click()
        else open = false
    }
</script>
