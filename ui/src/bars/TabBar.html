<div bind:this={tabBar} class="tab-bar">
    {#each tabData as t}
    <Tab {...t} bind:this={tabs[t.id]}></Tab>
    {/each}
</div>


<style>
    .tab-bar {
        width: 100%;
        height: var(--tab-bar-height);
        background: var(--panel-color);
        border-bottom: var(--panel-border);
        white-space: nowrap;
        overflow-x: visible;
        z-index: 800;
    }

</style>

   

<script>
    import { onMount } from 'svelte';

    // [svelte-upgrade suggestion]
    // manually refactor all references to __this
    const __this = {
        get: () => ({ parent })
    };

    export let tabBar;

    import Tab from './Tab.html'
    import Sortable from 'sortablejs'
    import elementQueries from 'css-element-queries'
    import { nextFrame } from '../lib/Utils.js'

    export let parent = null
    export let tabData = []
    export let tabs = {}
    let tabFittingTask = -1

    onMount(() => {
        __this.tabs = new Set()
        __this.sortable = Sortable.create(tabBar, {
            animation: 0,
        })
//        new elementQueries.ResizeSensor(tabBar, () => {
//            fitTabWidth()
//        })
    });

    // [svelte-upgrade suggestion]
    // review these functions and remove unnecessary 'export' keywords
    export function openTab(id, name, view, icon, labeled = false) {
        tabData.push({ id, name, view, icon, labeled })
        tabData = tabData
        fitTabWidth()
        view.tab = tabs[id]
    }

    export function switchToTab(index) {
        index += 1 // resizeSensor counts 1
        for (const tab of __this.tabs) {
            if (tab.getIndex() === index) {
                tab.activate()
                return
            }
        }
    }
    
    export function updateTabIndicator({ id, active }) {
        nextFrame(() => {
            tabs[id].active = active
        })
    }

    function _fitTabWidth() {
        const tabBarWidth = tabBar.getBoundingClientRect().width
        const _tabs = Object.values(tabs)
        if (!_tabs.length) return
        const equalTabWidth = tabBarWidth / _tabs.length

        const originalWidths = _tabs.map(t => t.getInternalWidth())
        const totalTabWidth = originalWidths.reduce((a, b) => a + b)
        let largerThanEqualTabWidth = 0
        const spareTabSpace = originalWidths.reduce((a, b) => {
            if (b < equalTabWidth)
                return equalTabWidth - b + a
            largerThanEqualTabWidth += 1
            return a
        }, 0)

        const paddingPerSide = Math.max((tabBarWidth - totalTabWidth) / _tabs.length / 2, 0)

        const newTabWidth = equalTabWidth + (spareTabSpace / largerThanEqualTabWidth)
        for (let i = 0; i < _tabs.length; i++) {
            const tab = _tabs[i]
            if ((paddingPerSide > 0) || (originalWidths[i] < equalTabWidth)) {
                tab.autoWidth()
                tab.padding = paddingPerSide
            } else {
                tab.forceSetWidth(newTabWidth)
            }
        }
    }
    
    export function fitTabWidth() {
        cancelAnimationFrame(tabFittingTask)
        tabFittingTask = requestAnimationFrame(_fitTabWidth)
    }
</script>

