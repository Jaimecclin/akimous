<div bind:this={tabBar} class="tab-bar">
    {#each tabData as t}
    <Tab {...t} bind:this={tabs[t.id]} on:requestTabClose></Tab>
    {/each}
</div>


<style>
    .tab-bar {
        width: 100%;
        height: var(--tab-bar-height);
        background: var(--panel-color);
        border-bottom: var(--panel-border);
        white-space: nowrap;
        overflow-x: visible;
        z-index: 800;
    }

</style>


<script>
    import { onMount, tick } from 'svelte'
    import Sortable from 'sortablejs'
    import elementQueries from 'css-element-queries'
    
    import Tab from './Tab.html'
    import { nextFrame } from '../lib/Utils.js'

    export let tabData = [],
        tabs = {}

    let tabFittingTask = -1,
        sortable,
        tabBar

    onMount(() => {
        sortable = Sortable.create(tabBar, { animation: 0 })
        new elementQueries.ResizeSensor(tabBar, fitTabWidth)
    })

    // [svelte-upgrade suggestion]
    // review these functions and remove unnecessary 'export' keywords
    export async function openTab(id, name, view, icon, labeled = false) {
        tabData.push({ id, name, view, icon, labeled })
        tabData = tabData
        fitTabWidth()
        await tick()
        view.tab = tabs[id]
    }

    export function switchToTab(index) {
        index += 1 // resizeSensor counts 1
        for (const tab of tabs) {
            if (tab.getIndex() === index) {
                tab.activate()
                return
            }
        }
    }
    
    export async function updateTabIndicator({ id, active }) {
        await tick()
        tabs[id].$set({ active })
    }

    function _fitTabWidth() {
        const tabBarWidth = tabBar.getBoundingClientRect().width
        const _tabs = Object.values(tabs)
        if (!_tabs.length) return
        const equalTabWidth = tabBarWidth / _tabs.length

        const originalWidths = _tabs.map(t => t.getInternalWidth())
        const totalTabWidth = originalWidths.reduce((a, b) => a + b)
        let largerThanEqualTabWidth = 0
        const spareTabSpace = originalWidths.reduce((a, b) => {
            if (b < equalTabWidth)
                return equalTabWidth - b + a
            largerThanEqualTabWidth += 1
            return a
        }, 0)

        const paddingPerSide = Math.max((tabBarWidth - totalTabWidth) / _tabs.length / 2, 0)

        const newTabWidth = equalTabWidth + (spareTabSpace / largerThanEqualTabWidth)
        for (let i = 0; i < _tabs.length; i++) {
            const tab = _tabs[i]
            if ((paddingPerSide > 0) || (originalWidths[i] < equalTabWidth)) {
                tab.autoWidth()
                tab.$set({ padding: paddingPerSide })
            } else {
                tab.forceSetWidth(newTabWidth)
            }
        }
    }
    
    export function fitTabWidth() {
        cancelAnimationFrame(tabFittingTask)
        tabFittingTask = requestAnimationFrame(_fitTabWidth)
    }
</script>

