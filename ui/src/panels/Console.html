<div id="console" class="panel" class:gone="{!active}">
    {#if mode === 'jupyter'}
    <div bind:this={jupyter} class="upper-half">
        <JupyterToolbar bind:this={g.jupyterToolbar}></JupyterToolbar>
        <table id="jupyter-cells">
            {#each cells as cell}
            {#if displayInput || !cell.code }
            <JupyterCell {...cell}></JupyterCell>
            {/if}
            {/each}
        </table>
    </div>
    {/if}
    <div id="terminal" bind:this={terminal} class="{mode === 'jupyter' ? 'lower-half' : 'full-height'}"></div>
</div>


<style>
    .upper-half {
        height: 70%;
    }
	
    .lower-half {
    	height: 30%;
    }

    :global(#terminal.full-height) {
        height: 100%;
    }

</style>

<script>
    import { afterUpdate, onDestroy, onMount, createEventDispatcher } from 'svelte'
    import Terminal from 'xterm/dist/xterm'
    import fit from 'xterm/lib/addons/fit/fit'
    
    import g from '../lib/Globals'
    import { nextFrame, schedule } from '../lib/Utils'
    
    import JupyterToolbar from './JupyterToolbar.html'
    import JupyterCell from './JupyterCell.html'

    // [svelte-upgrade suggestion]
    // manually refactor all references to __this
    const __this = {}
    const dispatch = createEventDispatcher()
    Terminal.applyAddon(fit)

    export let jupyter,
        jupyterToolbar,
        terminal,
        active = false,
        mode = '',
        cells = [
            // {
            //     output: {
            //         'text/plain': 'text',
            //     }
            // }
        ],
        displayInput = false,
        ready = false


    $: {
        dispatch('active', {
            id: 'console',
            active
        })
    }
    onMount(() => {
        __this.name = 'console'
        __this.initializing = false
//        initializeTabView(this, 'Console', 'fas fa-desktop l-purple')
    })

    onDestroy(() => {
        __this.session && __this.session.close()
    })

    // [svelte-upgrade warning]
    // beforeUpdate and afterUpdate handlers behave
    // differently to their v2 counterparts
    afterUpdate(() => {
//        if (changed.mode) {
//            stop()
//            close()
//            if (current.active) {
//                initialize()
//            }
//        }
//        if (changed.active) {
//            if (!current.ready && current.active) {
//                initialize()
//            }
//        }
    })

    // [svelte-upgrade suggestion]
    // review these functions and remove unnecessary 'export' keywords
    export function initialize() {
        if (__this.initializing) return
        __this.initializing = true
        
        __this.tab.set({ active: false })
        __this.tab.set({ active: true })
        
        document.fonts.ready.then(() => { 
            // make sure the font is already loaded 
            // (as it will not be replaced after terminal loads)
            schedule(() => {
                const rem = parseFloat(getComputedStyle(document.documentElement).fontSize)
                const terminal = new Terminal({
                    tabStopWidth: 4,
                    fontSize: 1.1 * rem,
                    fontFamily: 'DejaVuSansMono',
                    fontWeight: 400, // workaround for broken block (e.g. tqdm) rendering
                    theme: {
                        foreground: '#CCC',
                        background: '#3F3F3F'
                    },
                    convertEol: true,
                })
                __this.terminal = terminal
                terminal.open(terminal, false)

                terminal.on('focus', () => {
                    g.setFocus([g.panelRight, this])
                })
                terminal.addDisposableListener('data', data => {
                    __this.session.send('Stdin', data)
                })
                terminal.fit()
                if (mode === 'terminal') {
                    connectTerminal()
                } else if (mode === 'jupyter') {
                    connectJupyter()
                }
                __this.initializing = false
            })
        })
    }

    export function close() {
        ready = false
        if (__this.session) {
            __this.session.close()
            __this.session = null
        }
        if (__this.terminal) {
            __this.terminal.dispose()
            __this.terminal = null
        }
    }

    export function runDefault() {
        if (mode === 'terminal') {
            runInTerminal()
        } else if (mode === 'jupyter') {
            runInJupyter()
        }
    }

    export function connectTerminal() {
        const { terminal } = this

        __this.session = g.socket.createSession('terminal')
        const { handlers } = __this.session
        handlers['Stdout'] = message => {
            terminal.write(message)
        }
        handlers['Started'] = () => {
            terminal.clear()
            terminal.reset()
        }

        nextFrame(() => {
            terminal.write('Click "Run" on toolbar to run current script.\n')
            ready = true
        })
    }

    export function runInTerminal() {
        g.panelRight.activateView(g.panelRight.refs.console)
        const { mode, shellCommands, shellCommandIndex, args, cwd } = g.runConfiguration.get()

        const run = () => {
            if (!ready) {
                nextFrame(run)
                return
            }
            const { cols, rows } = __this.terminal
            __this.terminal.clear()

            const configuration = { mode, cols, rows }
            if (mode === 'shell') {
                configuration.command = shellCommands[shellCommandIndex]
            } else {
                const { filePath } = g.activeEditor.get()
                configuration.filePath = filePath
            }
            if (mode === 'script' || mode === 'module') {
                configuration.args = args
                configuration.cwd = cwd
            }
            __this.session.send('RunInTerminal', configuration)
        }

        run()
    }

    export function stop() {
        if (!__this.session) return
        if (mode === 'jupyter') {
            __this.session.send('StopKernel', {})
        } else {
            __this.session.send('Stop', {})
        }
    }

    export function connectJupyter() {
        if (__this.session)
            __this.session.close()
        __this.session = g.socket.createSession('jupyter')
        const { handlers } = __this.session
        
        Object.assign(handlers, {
            KernelStarted: () => {
                g.jupyterToolbar.set({
                    executionState: 'idle'
                })
                ready = true
            },
            IOPub: e => {
                const { execution_state } = e
                if (execution_state) {
                    g.jupyterToolbar.set({
                        executionState: execution_state
                    })
                }
                if (e.code) {
                    cells.push({
                        code: e.code,
                        executionCount: e.execution_count,
                    })
                    cells = cells
                }
                if (e.text) {
                    __this.terminal.write(e.text)
                }
                if (e.traceback) {
                    for (const line of e.traceback)
                        __this.terminal.write(line)
                    __this.terminal.write('\n')
                }
                if (e.data) {
                    cells.push({
                        output: e.data,
                        executionCount: e.execution_count || '',
                    })
                    cells = cells
                }
            },
            Clear: () => {
                cells.length = 0
                __this.terminal.clear()
            },
            KernelStopped: () => {
                g.jupyterToolbar.set({
                    executionState: 'stopped'
                })
            },
        })
    }

    export function runInJupyter() {
        g.panelRight.activateView(g.panelRight.refs.console)

        const run = () => {
            if (!ready) {
                nextFrame(run)
                return
            }
            __this.session.send('Run', {
                code: g.activeEditor.cm.getSelection()
            })
        }

        run()
    }

    export function startKernel(realtimeEvaluation) {
        if (!g.activeEditor) return
        g.jupyterToolbar.set({
            executionState: 'starting',
        })
        __this.session.send('StartKernel', { realtimeEvaluation })
        __this.realtimeEvaluationEditor = g.activeEditor
        g.activeEditor.cmEventDispatcher.realtimeEvaluation = realtimeEvaluation
    }

    export function stopRealtimeEvaluation() {
        __this.realtimeEvaluationEditor = null
        if (!g.activeEditor) return
        g.activeEditor.cmEventDispatcher.realtimeEvaluation = false
        console.warn('stopping')
    }

    export function evaluate(cursor) {
        delete cursor['sticky']
        console.log('evaluate', cursor)
        __this.session.send('Evaluate', cursor)
    }

    export function evaluatePartA(line) {
        if (__this.lastPartALine === line) {
            console.log('skipped evaluateA', line)
            return
        }
        console.warn('evaluateA', line)
        __this.session.send('EvaluatePartA', line)
        __this.lastPartALine = line
    }

    export function evaluatePartB(line, line_content) {
        console.log('evaluateB', line, performance.now())
        g.jupyterToolbar.set({
            executionState: 'busy'
        })
        __this.session.send('EvaluatePartB', {
            line,
            line_content
        })
    }
</script>