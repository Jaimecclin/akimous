<div id="console" class="panel" class:gone="!active">
    {#if mode === 'jupyter'}
    <div ref:jupyter class="half">
        <JupyterToolbar ref:jupyterToolbar></JupyterToolbar>
        <table id="jupyter-cells">
            {#each cells as cell}
            {#if displayInput || !cell.code }
            <JupyterCell {...cell}></JupyterCell>
            {/if}
            {/each}
        </table>
    </div>
    {/if}
    <div id="terminal" ref:terminal class="{mode === 'jupyter' ? 'half' : 'full-height'}"></div>
</div>


<style>
    .half {
        height: 50%;
    }

    :global(#terminal.full-height) {
        height: 100%;
    }

</style>


<script>
    import g from '../lib/Globals'
    import { initializeTabView, nextFrame, schedule } from '../lib/Utils'
    import Terminal from 'xterm/dist/xterm'
    import fit from 'xterm/lib/addons/fit/fit'

    Terminal.applyAddon(fit)

    export default {
        components: {
            JupyterToolbar: './JupyterToolbar.html',
            JupyterCell: './JupyterCell.html',
        },
        oncreate() {
            this.name = 'console'
            g.console = this
            initializeTabView(this, 'Console', 'fas fa-desktop l-purple')
        },
        onupdate({ changed, current }) {
            if (changed.mode) {
                this.stop()
                this.close()
                if (current.active) {
                    this.initialize()
                }
            }
            if (changed.active) {
                if (!current.ready && current.active) {
                    this.initialize()
                }
            }
        },
        data() {
            return {
                active: false,
                mode: '', // 'terminal' or 'jupyter'
                ready: false,
                cells: [
                    // {
                    //     output: {
                    //         'text/plain': 'text',
                    //     }
                    // }
                ],
                displayInput: false,
            }
        },
        methods: {
            initialize() {
                const { mode } = this.get()

                this.tab.set({ active: false })
                this.tab.set({ active: true })

                schedule(() => {
                    const rem = parseFloat(getComputedStyle(document.documentElement).fontSize)
                    const terminal = new Terminal({
                        tabStopWidth: 4,
                        fontSize: 1.2 * rem,
                        fontFamily: 'Inconsolata',
                        fontWeight: 400, // workaround for broken block (e.g. tqdm) rendering
                        theme: {
                            foreground: '#CCC',
                            background: '#3F3F3F'
                        },
                        convertEol: true,
                    })
                    this.terminal = terminal
                    terminal.open(this.refs.terminal, false)

                    terminal.on('focus', () => {
                        g.setFocus([g.panelRight, this])
                    })
                    terminal.addDisposableListener('data', data => {
                        this.session.send('Stdin', data)
                    })

                    terminal.fit()

                    if (mode === 'terminal') {
                        this.connectTerminal()
                    }
                    if (mode === 'jupyter') {
                        this.connectJupyter()
                    }
                })
            },
            close() {
                this.set({ ready: false })
                if (this.session) {
                    this.session.close()
                    this.session = null
                }
                if (this.terminal) {
                    this.terminal.dispose()
                    this.terminal = null
                }
            },
            runDefault() {
                const { mode } = this.get()
                if (mode === 'terminal') {
                    this.runInTerminal()
                } else if (mode === 'jupyter') {
                    this.runInJupyter()
                }
            },

            // Terminal
            connectTerminal() {
                const { terminal } = this

                this.session = g.socket.createSession('terminal')
                const { handlers } = this.session
                handlers['Stdout'] = message => {
                    terminal.write(message)
                }
                handlers['Started'] = () => {
                    terminal.clear()
                    terminal.reset()
                }

                nextFrame(() => {
                    terminal.write('Click "Run" on toolbar to run current script.\n')
                    this.set({ ready: true })
                })
            },

            runInTerminal() {
                g.panelRight.activateView(g.panelRight.refs.console)
                const { mode, shellCommands, shellCommandIndex, args, cwd } = g.runConfiguration.get()

                const run = () => {
                    const { ready } = this.get()
                    if (!ready) {
                        nextFrame(run)
                        return
                    }
                    const { cols, rows } = this.terminal
                    this.terminal.clear()

                    const configuration = { mode, cols, rows }
                    if (mode === 'shell') {
                        configuration.command = shellCommands[shellCommandIndex]
                    } else {
                        const { filePath } = g.activeEditor.get()
                        configuration.filePath = filePath
                    }
                    if (mode === 'script' || mode === 'module') {
                        configuration.args = args
                        configuration.cwd = cwd
                    }
                    this.session.send('RunInTerminal', configuration)
                }

                run()
            },
            stop() {
                if (!this.socket) return
                const { mode } = this.get()
                if (mode === 'jupyter') {
                    this.session.send('StopKernel', {})
                } else {
                    this.session.send('Stop', {})
                }
            },

            // Jupyter
            connectJupyter() {
                if (this.session)
                    this.session.close()
                this.session = g.socket.createSession('jupyter')
                const { handlers } = this.session
                
                Object.assign(handlers, {
                    KernelStarted: () => {
                        g.jupyterToolbar.set({
                            executionState: 'idle'
                        })
                        this.set({ ready: true })
                    },
                    IOPub: e => {
                        const { cells } = this.get()
                        const { execution_state } = e
                        if (execution_state) {
                            g.jupyterToolbar.set({
                                executionState: execution_state
                            })
                        }
                        if (e.code) {
                            cells.push({
                                code: e.code,
                                executionCount: e.execution_count,
                            })
                            this.set({ cells })
                        }
                        if (e.text) {
                            this.terminal.write(e.text)
                        }
                        if (e.traceback) {
                            for (const line of e.traceback)
                                this.terminal.write(line)
                            this.terminal.write('\n')
                        }
                        if (e.data) {
                            cells.push({
                                output: e.data,
                                executionCount: e.execution_count,
                            })
                            this.set({ cells })
                        }
                    },
                    Clear: () => {
                        const { cells } = this.get()
                        cells.length = 0
                        this.terminal.clear()
                    },
                    KernelStopped: () => {
                        g.jupyterToolbar.set({
                            executionState: 'stopped'
                        })
                    },
                })
            },
            runInJupyter() {
                g.panelRight.activateView(g.panelRight.refs.console)

                const run = () => {
                    const { ready } = this.get()
                    if (!ready) {
                        nextFrame(run)
                        return
                    }
                    this.session.send('Run', {
                        code: g.activeEditor.cm.getSelection()
                    })
                }

                run()
            },
            startKernel(realtimeEvaluation) {
                if (!g.activeEditor) return
                g.jupyterToolbar.set({
                    executionState: 'starting',
                })
                this.session.send('StartKernel', { realtimeEvaluation })
                this.realtimeEvaluationEditor = g.activeEditor
                g.activeEditor.cmEventDispatcher.realtimeEvaluation = realtimeEvaluation
                console.warn('starting')
            },
            stopRealtimeEvaluation() {
                this.realtimeEvaluationEditor = null
                if (!g.activeEditor) return
                g.activeEditor.cmEventDispatcher.realtimeEvaluation = false
                console.warn('stopping')
            },
            evaluate(cursor) {
                delete cursor['sticky']
                console.log('evaluate', cursor)
                this.session.send('Evaluate', cursor)
            },
            evaluatePartA(line) {
                if (this.lastPartALine === line) {
                    console.log('skipped evaluateA', line)
                    return
                }
                console.warn('evaluateA', line)
                this.session.send('EvaluatePartA', line)
                this.lastPartALine = line
            },
            evaluatePartB(line, line_content) {
                console.log('evaluateB', line, performance.now())
                g.jupyterToolbar.set({
                    executionState: 'busy'
                })
                this.session.send('EvaluatePartB', {
                    line,
                    line_content
                })
            }
        }
    }

</script>
