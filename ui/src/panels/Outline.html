<div bind:this={panel} class="panel" class:gone="{!active}" on:click="{onFocus}">
    <table bind:this={outline} id="outline">
        {#each outlineItems as { line, display, type, level }, i }
        <tr bind:this={row} on:click="{() => jumpTo(line, display)}" class="outline-node" class:highlight="{line<=currentLine && (!outlineItems[i+1] || currentLine<outlineItems[i+1].line)}">
<!--            <td class="line-number" class:highlight>{line + 1}</td>-->
            <td class="line-number">{line + 1}</td>
            {#each Array(level) as indent}
            <td class="indent"></td>
            {/each}
            <td class="row-body {type}">{display}</td>
        </tr>
        {:else}
            <tr>
                <td class="placeholder">Empty <br>(classes and functions defined in your code will be shown here)</td>
            </tr>
        {/each}
    </table>
</div>

<style>
    .outline-node {
        height: var(--ui-line-height-default);
        white-space: nowrap;
        min-width: 100%;
        display: inline-flex;
    }

    .indent {
        display: inline-block;
        width: 1rem;
        height: 100%;
        color: transparent;
        box-sizing: border-box;
        border-right: .05rem solid var(--panel-delimiter-color);
    }

    .row-body {
        display: inline-block;
        flex-grow: 1;
    }

    .row-body.def {
        color: var(--c-function);
    }

    .row-body.class {
        color: var(--c-def);
    }

    .row-body.async {
        color: var(--c-attribute);
    }

</style>
   

<script>
    import { onMount } from 'svelte';

    // [svelte-upgrade suggestion]
    // manually refactor all references to __this
    const __this = {};

    export let panel;
    export let outline;
    export let row;

    import g from '../lib/Globals'
    import { initializeTabView, Pos } from '../lib/Utils'
    import { makeScrollable } from '../lib/UIUtils'
    import { setCursorAndScrollIntoView } from '../editor/EditorFunctions'

    export let active = false;
    export let outlineItems = [];
    export let currentLine = 0;

    onMount(() => {
//        __this.name = 'outline'
//        g.outline = this
        g.currentHighlight = null
//        initializeTabView(this, 'Outline', 'fas fa-align-left l-blue')
//        makeScrollable(this, panel)
    });

    // [svelte-upgrade suggestion]
    // review these functions and remove unnecessary 'export' keywords
    export function onFocus() {
        g.setFocus([g.panelLeft, this])
    }

    export function generateOutline(cm) {
        const lineCount = cm.lineCount()
        const indentUnit = cm.getOption('indentUnit')
        const result = []
        for (let line = 0; line < lineCount; line++) {
            let indent = 0,
                token
            try {
                token = cm.getTokenAt(Pos(line, 1))
            } catch (e) {
                continue
            }
            if (!token.type) {
                if (!/\S/.test(token.string)) {
                    indent = token.end
                    try {
                        token = cm.getTokenAt(Pos(line, indent + 1))
                    } catch (e) {
                        continue
                    }
                }
            }
            if (token.type !== 'keyword') continue
            let type = token.string
            let asynchronous = false
            if (type === 'async') {
                try {
                    token = cm.getTokenAt(Pos(line, token.end + 2))
                    type = token.string
                    asynchronous = true
                } catch (e) {
                    continue
                }
            }
            if (type === 'def' || type === 'class') {
                try {
                    token = cm.getTokenAt(Pos(line, token.end + 2)) // skip over the space after the keyword
                } catch (e) {
                    continue
                }
                if (asynchronous === true)
                    type = 'async'
                result.push({
                    level: indent / indentUnit,
                    display: token.string,
                    type,
                    line
                })
            } else {
                continue
            }
        }
        return result
    }

    export function jumpTo(line, name) {
        let ch = 0
        const lineContent = g.activeEditor.cm.getLine(line)
        ch = lineContent.indexOf(name)
        setCursorAndScrollIntoView(line, ch)
    }
</script>


