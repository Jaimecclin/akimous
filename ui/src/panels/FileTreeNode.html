<div bind:this={row} on:mousedown="{onClick}" on:dblclick="{onDoubleClick}" on:contextmenu="{onContextMenu}" class="file-tree-node" class:selected class:hidden-file="{name.startsWith('.')}" style="padding-left: {0.3 + level}rem;">
    <span class="icon {icon}"></span> 
    {#if !renaming}
    <span class="display-name">
        {name}
    </span> 
    {:else}
    <input bind:this={input} class="display-name" type="text" spellcheck="false" value="{name}" on:blur="{commitRename}"> 
    {/if}
</div>

{#if newNode}
<svelte:self bind:this={placeholderNode} placeholderMode={true} level={level+isDir} parent={self} isDir="{ newNode==='dir' }" /> 
{/if}

<div bind:this={children}>
    {#each dirs as i (i.uid)}
    <svelte:self level={level+1} name={i.name} parent={self} isDir /> 
    {/each} 
    {#each files as i (i.uid)}
    <svelte:self level={level+1} name={i.name} parent={self} /> 
    {/each}
</div>


<style>
    .file-tree-node {
        height: var(--ui-line-height-default);
        line-height: var(--ui-line-height-default);
        cursor: default;
        white-space: nowrap;
        min-width: 100%;
        font-size: var(--ui-font-size-default);
        /* don't remove this or the font on non-retina display with Safari will become crappy. */
        background: var(--panel-color);
    }

    .file-tree-node.selected {
        background: var(--ui-highlight-color);
        color: white;
    }

    .file-tree-node:hover {
        color: white;
    }

    .icon {
        width: 1rem;
        min-height: 1rem;
        display: inline-block;
        vertical-align: text-bottom;
        background-size: 100% 100% !important;
        text-align: center;
    }

    .display-name {
        padding-left: 0.3rem;
        vertical-align: middle;
    }

    input.display-name {
        border-radius: var(--small-radius);
        font-size: var(--ui-font-size-default);
        height: var(--ui-font-size-default);
    }

    .hidden-file .icon,
    .hidden-file .display-name {
        opacity: 0.6;
    }

</style>

<script>
    import { beforeUpdate, onDestroy, onMount, createEventDispatcher } from 'svelte';

    // [svelte-upgrade suggestion]
    // manually refactor all references to __this
    const __this = {
        get: () => ({ renaming, name, level, icon, newNode, isDir, self, dirs, files, parent, open, selected, placeholderMode })
    };

    const dispatch = createEventDispatcher()
    export let row = null
    export let input = ''
    export let placeholderNode = null
    export let children = {}

    import g from '../lib/Globals'
    import { binarySearch, schedule } from '../lib/Utils'

    import { fileTypeToIcon, getIconByFileName, } from '../lib/FileTypeToIcon'
    import pressure from 'pressure'

    const copyPath = {
        text: 'Copy Path',
        icon: 'fas fa-link',
        clipboardText: null
    }
    
    const contextMenu = [{
        text: 'New File',
        icon: 'far fa-file',
        callback: (target) => {
            target.newFile()
        }
    }, {
        text: 'New Folder',
        icon: 'fas fa-folder',
        callback: (target) => {
            target.newFolder()
        }
    }, {
        text: 'New Python Module',
        icon: 'fas fa-cube',
        callback: (target) => {
            target.newModule()
        }
    }, {
        divider: true
    }, {
        text: 'Find in directory...',
        icon: 'fas fa-search',
        callback: (target) => {
            target.findIn()
        }
    }, {
        text: 'Replace in directory...',
        icon: 'fas fa-retweet',
        callback: (target) => {
            target.replaceIn()
        }
    }, {
        text: 'Rename',
        icon: 'fas fa-pen-square',
        callback: (target) => {
            target.rename()
        }
    }, {
        text: 'Delete',
        icon: 'fas fa-trash',
        callback: (target) => {
            target.del()
        }
    }, {
        text: 'Show in File Manager',
        icon: 'fas fa-external-link-alt',
        callback: (target) => {
            target.openInFileManager()
        }
    }, copyPath]
    
    const keyEventHandler = {
        handleKeyEvent(e, target) {
            if (!target.get().renaming) return true
            switch (e.key) {
                case 'Enter':
                    target.commitRename()
                    break
                case 'Escape':
                    target.endRenaming()
                    break
                default:
                    return true // if not handled
            }
            return false
        },
        handleCommand( /*command, target*/ ) {
            return true
        }
    }

    export let renaming = false;
    export let name = '';
    export let level = 0;
//    export let icon = '';
    export let newNode = null;
    export let isDir = false;
    export let dirs = [];
    export let files = [];
    export let parent;
    export let open = false;
    export let selected = false;
    export let placeholderMode = false;
    
    export let icon
    $: icon = isDir ? fileTypeToIcon['folder'] : getIconByFileName(name)

    const methods = {
        
    }
    
    onMount(() => {
        __this.children = {}
        __this.renamingCommittedCallback = null
//        schedule(() => {
//            __this.cancelAllSelectionListener = g.fileTree.on('cancelAllSelection', () => {
//                selected = false
//            })
//            pressure.set(row, {
//                startDeepPress: () => { rename() }
//            })
//        })

        if (placeholderMode)
            onClick() // select this node if it is a placeholder

        dispatch('created', { name, methods })
    });

    onDestroy(() => {
        __this.cancelAllSelectionListener && __this.cancelAllSelectionListener.cancel()
        removeChildren()
        if (__this.get().selected) {
            try {
                let node = sibling(-1)
                if (node && node !== this) return node.onClick()
                node = sibling(1)
                if (node && node !== this) return node.onClick()
//                node = __this.get().parent
//                if (node) return node.onClick()
            } catch (e) {
                // swallow exception
            }
        }
        g.popFocus(this)
    });

    // [svelte-upgrade warning]
    // beforeUpdate and afterUpdate handlers behave
    // differently to their v2 counterparts
    beforeUpdate(() => {
//        if (changed.name) {
//            if (previous && previous.name) delete parent.children[previous.name]
//            parent.children[current.name] = this
//        } else if (changed.open && current.isDir) {
//            if (current.open) {
//                icon = fileTypeToIcon['folder-open']
//            } else {
//                icon = fileTypeToIcon['folder']
//            }
//        }
    });

    export let allowWhiteSpace;
    $: allowWhiteSpace = renaming;

    // [svelte-upgrade suggestion]
    // review these functions and remove unnecessary 'export' keywords
    export function getPath() {
        const path = [__this.get().name]
        let { name } = parent.get()
        while (name) {
            path.push(name)
            parent = parent.get().parent
            name = parent.get().name
        }
        return path.reverse()
    }

    export function onClick() {
        if (selected) return
        g.fileTree.fire('cancelAllSelection')
        selected = true
        if (event || g.focusStack[0] === g.panelLeft) // avoid focus being stolen on startup
            g.setFocus([g.panelLeft, g.fileTree, this])
    }

    export function onDoubleClick() {
        if (__this.get().isDir) {
            open = !open
            open = open
            if (open) {
                g.fileTree.session.send('OpenDir', {
                    path: getPath(),
                })
            } else {
                files = [], dirs = []
                g.fileTree.session.send('CloseDir', {
                    path: getPath()
                })
            }
        } else {
            g.panelMiddle.openFile(getPath())
        }

    }

    export function onContextMenu(e) {
        g.fileTree.fire('cancelAllSelection')
        selected = true
        copyPath.clipboardText = getAbsolutePath()
        g.contextMenu.set({
            open: true,
            x: e.clientX,
            y: e.clientY,
            items: contextMenu,
            caller: this
        })
        e.preventDefault()
    }

    export function redraw() {
        dirs = dirs.sort((a, b) => a.name > b.name), files = files.sort((a, b) => a.name > b.name)
    }

    export function removeChildren() {
        dirs = [], files = []
    }

    export function rename() {
        renaming = true
        input.focus()
    }

    export function commitRename() {
        if (!renaming) return // prevent event being triggered twice (one from enter, one from blur)
        if (input.value !== __this.get().name && input.value.length > 0) {
            if (__this.get().placeholderMode) {
                name = this.refs.input.value
                const path = getPath()
                const { isDir } = parent.get()
                if (!isDir)
                    path.splice(-2, 1) // remove if its parent is a file, not the real parent
                if (__this.renamingCommittedCallback)
                    __this.renamingCommittedCallback(path)
            } else {
                g.fileTree.session.send('Rename', {
                    path: getPath(),
                    newName: input.value
                })
            }
        }
        endRenaming()
    }

    export function endRenaming() {
        if (__this.get().placeholderMode) {
            __this.get().parent.set({ newNode: null })
        } else {
            renaming = false
        }
    }

    export function newFile() {
        newNode = 'file'
        placeholderNode.rename()
        placeholderNode.renamingCommittedCallback = path => {
            g.fileTree.session.send('CreateFile', { path })
            // select newly created node after file tree updated
            g.fileTree.addNodeCreatedCallback(path, node => node.onClick())
        }
    }

    export function newFolder() {
        newNode = 'dir'
        placeholderNode.rename()
        placeholderNode.renamingCommittedCallback = path => {
            g.fileTree.session.send('CreateDir', { path })
            g.fileTree.addNodeCreatedCallback(path, node => node.onClick())
        }
    }

    export function newModule() {
        newNode = 'dir'
        placeholderNode.rename()
        placeholderNode.renamingCommittedCallback = path => {
            g.fileTree.session.send('CreateDir', { path })
            g.fileTree.session.send('CreateFile', { path: [...path, '__init__.py'] })
            g.fileTree.addNodeCreatedCallback(path, node => node.onClick())
        }
    }

    export function del() {
        g.fileTree.session.send('Delete', {
            path: getPath(),
        })
    }

    export function sibling(direction) {
        const { files, dirs } = parent.get()
        const list = isDir ? dirs : files
        const currentIndex = binarySearch(list, __this.get().name)

        let newList = list
        let newIndex = currentIndex + (direction > 0 ? 1 : -1)
        if (direction > 0 && newIndex >= list.length) {
            if (!isDir) return this
            if (files.length) {
                newList = files
                newIndex = 0
            } else return this
        } else if (direction < 0 && newIndex < 0) {
            if (isDir) return this
            if (dirs.length) {
                newList = dirs
                newIndex = dirs.length - 1
            } else return this
        }
        const nextNodeName = newList[newIndex].name
        return parent.children[nextNodeName]
    }

    export function firstChild() {
        if (dirs.length) return __this.children[dirs[0].name]
        if (files.length) return __this.children[files[0].name]
        return null
    }

    export function lastChild() {
        if (files.length) return __this.children[files[files.length - 1].name]
        if (dirs.length) return __this.children[dirs[dirs.length - 1].name]
        return null
    }

    export function neighbor(direction) {
        if (direction > 0) {
            const firstChild = firstChild()
            if (firstChild) return firstChild
            const sibling = sibling(1)
            if (sibling && sibling !== this) return sibling
            if (!parent.sibling) return null
            return parent.sibling(1)
        } else {
            const sibling = sibling(-1)
            if (!sibling || sibling === this) return parent
            let node = sibling
            while (Object.keys(node.children).length) {
                const lastChild = node.lastChild()
                if (!lastChild) break
                node = lastChild
            }
            return node
        }
    }

    export function findIn() {
        const path = getPath()
        if (!__this.get().isDir) path.pop()
        g.find.reset()
        g.find.set({ 
            findInDirectory: path,
            replaceMode: false,
        })
        g.panelRight.activateView(g.panelRight.refs.find)
        g.setFocus([g.panelRight, g.find])
        g.find.refs.findText.focus()
        g.find.findInDirectory()
    }

    export function replaceIn() {
        findIn()
        g.find.set({ replaceMode: true })
    }

    export function openInFileManager() {
        g.fileTree.session.send('OpenInFileManager', {
            path: getPath(),
        })
    }

    export function getAbsolutePath() {
        const path = g.projectRoot.concat(getPath())
        let pathString = path.join(g.pathSeparator)
        pathString = pathString.replace(g.pathSeparator + g.pathSeparator, g.pathSeparator)
        return pathString
    }
</script>

