<div ref:panel id="find" class="panel" class:gone="!active" on:click="onFocus()">
    <div class="label">Find...</div>
    <TextInput ref:findText bind:value=findText coalesced="true" on:keydown="onKeyDown(event)"></TextInput>
    <div class="button-group">
        <Button label="Aa" corner="0001" active={caseSensitive} on:click="set({ caseSensitive: !caseSensitive })"></Button>
        <Button label=".*" active={regex} on:click="set({ regex: !regex })"></Button>
        <Button label="=" corner="0010" active={wholeWord} on:click="set({ wholeWord: !wholeWord })"></Button>
        <span class="gap"></span>
        <Button ref:findPrevious label="<i class='fas fa-caret-left'></i>" corner="0001" on:click="find(-1)"></Button>
        <Button ref:findNext label="<i class='fas fa-caret-right'></i>" corner="0010" on:click="find(1)"></Button>
    </div>
    {#if replaceMode}
    <div class="label">Replace with...</div>
    <TextInput ref:replaceText bind:value=replaceText coalesced="true"></TextInput>
    <div class="button-group">
        <Button label="Replace" corner="0001"></Button>
        <Button label="Batch"></Button>
        <Button label="All" corner="0010"></Button>
    </div>
    {/if}
</div>

<style>
    .label {
        margin: .7rem 0 .2rem .5rem;
    }

    .button-group {
        margin: 0 .3rem .3rem .3rem;
        display: flex;
    }

    .gap {
        flex-grow: 5;
    }

</style>


<script>
    import g from '../lib/Globals'
    import { initializeTabView, Pos } from '../lib/Utils'
    import { makeScrollable } from '../lib/UIUtils'

    const overlayOption = {
        opaque: true,
        priority: 0,
    }

    export default {
        components: {
            TextInput: '../lib/TextInput.html',
            Button: '../lib/Button.html',
        },
        oncreate() {
            g.find = this
            initializeTabView(this, 'Find', 'fas fa-search l-blue')
            makeScrollable(this, this.refs.panel)
            this.searchState = {}
            this.shouldRepaintOverlay = false
        },
        data() {
            return {
                active: false,
                replaceMode: false,
                findText: '',
                replaceText: '',

                caseSensitive: false,
                regex: false,
                wholeWord: false,

                highlightOverlay: null,
                textMark: null,
            }
        },
        onstate({ changed, current, previous }) {
            if (!previous) return
            if (changed.highlightOverlay && g.activeEditor) {
                const editor = g.activeEditor
                const cm = editor.cm
                if (cm) {
                    cm.removeOverlay(previous.highlightOverlay)
                    if (current.highlightOverlay) {
                        cm.setOption('highlightSelectionMatches', null) // pause highlightSelectionMatches
                        editor.set({ hideTextSelection: true }) // disable text selection marking
                        cm.addOverlay(current.highlightOverlay, overlayOption)
                    } else { // resume highlightSelectionMatches
                        const currentOption = cm.getOption('highlightSelectionMatches')
                        if (editor.highlightSelectionMatches !== currentOption)
                            cm.setOption('highlightSelectionMatches', editor.highlightSelectionMatches)
                        editor.set({ hideTextSelection: false }) // resume text selection marking
                    }
                    this.shouldRepaintOverlay = false
                }
            }
            if (changed.findText || changed.caseSensitive || changed.regex || changed.wholeWord)
                this.shouldRepaintOverlay = true
            if (changed.textMark && previous.textMark) {
                previous.textMark.clear()
            }
        },
        methods: {
            onFocus() {
                g.setFocus([g.panelRight, this])
            },
            clearHighlight() {
                this.set({
                    highlightOverlay: null,
                    textMark: null
                })
                this.shouldRepaintOverlay = true
            },
            onKeyDown(event) {
                if (event.key === 'Enter') {
                    this.find(1)
                    this.refs.findNext.flash()
                }
                return true
            },
            find(direction) {
                const cm = g.activeEditor.cm
                const caseInsensitive = false
                const action = direction > 0 ? 'findNext' : 'findPrevious'
                const { findText } = this.get()
                const { searchState } = this
                const query = new RegExp(findText.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&'),
                    caseInsensitive ? 'gi' : 'g')
                let searchCursor = cm.getSearchCursor(query,
                    direction > 0 ? cm.getCursor('to') : cm.getCursor('from'))
                let found = searchCursor[action]()

                if (!found) { // wrap around
                    searchCursor = cm.getSearchCursor(query,
                        direction > 0 ? Pos(cm.firstLine(), 0) : Pos(cm.lastLine()))
                    found = searchCursor[action]()
                }
                if (!found) return

                let from = searchCursor.from()
                let to = searchCursor.to()
                const pos = { from, to }
                cm.setSelection(from, to)
                cm.scrollIntoView(pos, 20)
                searchState.foundPos = pos

                const textMark = cm.markText(from, to, {
                    className: 'cm-searching-marked'
                })
                this.set({ textMark })

                if (!this.shouldRepaintOverlay)
                    return
                const highlightOverlay = {
                    token(stream) {
                        query.lastIndex = stream.pos
                        const match = query.exec(stream.string)
                        if (match && match.index == stream.pos) {
                            stream.pos += match[0].length || 1
                            return 'searching'
                        } else if (match) {
                            stream.pos = match.index
                        } else {
                            stream.skipToEnd()
                        }
                    }
                }
                this.set({ highlightOverlay })
            }
        }
    }

</script>
