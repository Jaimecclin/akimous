<div ref:panel id="find" class="panel" class:gone="!active" on:click="onFocus()">
    <div class="label">Find...</div>
    <TextInput ref:findText bind:value=findText coalesced="true" on:keydown="onKeyDown(event)"></TextInput>
    <div class="button-group">
        <Button corner="0001" active={caseSensitive} on:click="set({ caseSensitive: !caseSensitive })">Aa</Button>
        <Button active={regex} on:click="set({ regex: !regex })">.*</Button>
        {#if findInDirectory}
        <Button corner="0000" active={wholeWord} on:click="set({ wholeWord: !wholeWord })"><i class="far fa-square"></i></Button>
        <Button corner="0010" active={subdirectory} on:click="set({ subdirectory: !subdirectory })"><i class="fas fa-sitemap"></i></Button>
        {:else}
        <Button corner="0010" active={wholeWord} on:click="set({ wholeWord: !wholeWord })"><i class="far fa-square"></i></Button>
        {/if}
        <span class="gap"></span>
        <Button ref:findPrevious corner="0001" on:click="findNext(-1)"><i class="fas fa-caret-left"></i></Button>
        <Button ref:findNext corner="0010" on:click="findNext(1)"><i class="fas fa-caret-right"></i></Button>
    </div>
    {#if replaceMode}
    <div class="label">Replace with...</div>
    <TextInput ref:replaceText bind:value=replaceText coalesced="true"></TextInput>
    <div class="button-group">
        <Button corner="0011">All</Button>
        <span class="gap"></span>
        <Button corner="0001" on:click="replace(-1)"><i class="fas fa-caret-left"></i></Button>
        <Button on:click="replace(0)">Replace</Button>
        <Button corner="0010" on:click="replace(1)"><i class="fas fa-caret-right"></i></Button>
    </div>
    {/if}

    {#if findInDirectory}
    <div class="group-wrapper">
        {#if matches.length > 2999}
        <div class="message l-red"><i class="fas fa-exclamation-triangle"></i> Cannot display all results (too many matches)</div>
        {:elseif overflow}
        <div class="message l-orange"><i class="fas fa-exclamation-circle"></i> Search paused (too many matches)</div>
        <span class="gap"></span>
        <Button corner="1111" on:click="findInDirectory(2999)">Continue</Button>
        {/if}
    </div>
    {/if}

    <div class="group-wrapper">
        <div id="search-counter" class="message" class:hidden="selectedIndex < 0 && !findInDirectory">
            {#if findInDirectory}
            {matches.length} matches in {nFiles} files
            {:else}
            {selectedIndex + 1} of {matches.length} matches
            {/if}
        </div>
        <span class="gap"></span>
        <Button corner="1111" on:click="selectAll()">Select All</Button>
    </div>
    <table id="found-matches">
        {#each matches as match}
        {#if Array.isArray(match)}
        <tr class="matched-file">
            <td class="line-number"><i class="fas fa-file"></i></td>
            <td class="match">{joinPath(match)}</td>
        </tr>
        {:else}
        <tr class:highlight="selectedMatches.size === 0 && currentLine === match.from.line && isEqual(currentFilePath, match.filePath)">
            <td class="line-number" class:selected="selectedMatches.has(match)" on:click="toggleSelection(match)">{match.from.line + 1}</td>
            <td class="match" on:click="jumpTo(match)">{@html match.display}</td>
        </tr>
        {/if}
        {:else}
        <tr>
            <td class="placeholder">No matches found.</td>
        </tr>
        {/each}
    </table>
</div>

<style>
    .label {
        margin: .7rem 0 .2rem .5rem;
    }

    .button-group {
        margin: 0 .3rem .3rem .3rem;
        display: flex;
    }

    .gap {
        flex-grow: 5;
    }

    td.selected {
        background: var(--accent4);
    }

    .match {
        padding: .3rem .5rem;
        background: var(--gray2);
    }

    .match :global(em) {
        color: var(--brighter-yellow);
        font-style: normal;
    }

    .group-wrapper {
        margin: .3rem .3rem .3rem .5rem;
        display: flex;
        align-items: center;
    }

    .message {
        padding-right: .5rem;
        margin: 0;
    }

    .matched-file .line-number {
        color: var(--accent7);
        background: var(--accent3);
        text-align: center;
        padding-right: 0;
    }

    .matched-file .match {
        color: var(--accent7);
        background: var(--accent2);
    }

</style>


<script>
    import g from '../lib/Globals'
    import { initializeTabView, nextFrame, Pos, joinPath } from '../lib/Utils'
    import { makeScrollable } from '../lib/UIUtils'
    import { setCursorAndScrollIntoView } from '../editor/EditorFunctions'
    import isEqual from 'lodash.isequal'

    const textMarkOption = {
        className: 'cm-searching-marked'
    }

    function searchOverlayGenerator(query) {
        return {
            token(stream) {
                query.lastIndex = stream.pos
                const match = query.exec(stream.string)
                if (match && match.index == stream.pos) {
                    stream.pos += match[0].length || 1
                    return 'searching'
                } else if (match) {
                    stream.pos = match.index
                } else {
                    stream.skipToEnd()
                }
            }
        }
    }

    export default {
        components: {
            TextInput: '../lib/TextInput.html',
            Button: '../lib/Button.html',
        },
        helpers: {
            joinPath,
            isEqual,
        },
        oncreate() {
            this.name = 'find'
            g.find = this
            initializeTabView(this, 'Find', 'fas fa-search l-blue')
            makeScrollable(this, this.refs.panel)
            this.jobAnimationFrameId = 0
            g.projectSession.handlers['FoundInDirectory'] = ({ result, overflow, nFiles }) => {
                const m = []
                for (const { file, matches } of result) {
                    m.push(file)
                    for (const [line, from, to, text] of matches) {
                        const head = text.substring(0, from)
                        const body = text.substring(from, to)
                        const tail = text.substring(to)
                        const display = `${head}<em>${body}</em>${tail}`
                        m.push({
                            from: Pos(line, from),
                            to: Pos(line, to),
                            filePath: file,
                            display,
                        })
                    }
                }
                this.set({
                    matches: m,
                    nFiles,
                    overflow
                })
            }
        },
        data() {
            return {
                active: false,
                replaceMode: false,

                findText: '',
                replaceText: '',

                caseSensitive: false,
                regex: false,
                wholeWord: false,

                matches: [],
                selectedIndex: -1,
                selectedMatches: new Set(),

                currentFilePath: [],
                currentLine: 0,
                currentCh: 0,

                findInDirectory: null,
                subdirectory: true,

                nFiles: 0,
                overflow: false,
                cannotDisplay: false,
            }
        },
        onstate({ changed, previous, current }) {
            if (!previous) return
            const editor = g.activeEditor
            if (changed.findText || changed.caseSensitive || changed.regex || changed.wholeWord || changed.subdirectory) {
                if (current.findInDirectory)
                    this.findInDirectory()
                else if (editor)
                    this.findInFile(editor)
                this.set({ selectedIndex: -1 })
            }
            if (changed.selectedMatches && editor) {
                const { cm } = editor
                const { filePath } = editor.get()
                if (current.selectedMatches.size) {
                    const selections = []
                    for (const s of current.selectedMatches) {
                        if (isEqual(s.filePath, filePath))
                            selections.push({
                                anchor: s.from,
                                head: s.to
                            })
                    }
                    cm.setSelections(selections)
                    editor.set({ highlightOverlay: null })
                    this.set({ selectedIndex: -1 })
                } else if (current.selectedIndex === -1) {
                    cm.setCursor(cm.getCursor()) // clear selections if nothing selected
                }
            }
        },
        methods: {
            onFocus() {
                g.setFocus([g.panelRight, this])
            },
            onKeyDown(event) {
                if (event.key === 'Enter') {
                    this.findNext(1)
                    this.refs.findNext.flash()
                }
                return true
            },
            getQuery() {
                const { findText, caseSensitive, regex, wholeWord } = this.get()
                if (!findText.length) return
                let regexString = findText
                if (!regex) regexString = findText.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&')
                if (wholeWord) regexString = `\\b${regexString}\\b`
                return new RegExp(regexString, caseSensitive ? 'g' : 'gi')
            },
            findNext(direction) {
                let { findInDirectory, selectedIndex, matches } = this.get()
                if (findInDirectory) {
                    const { length } = matches
                    if (selectedIndex === -1) {
                        selectedIndex = length - 1
                    } else {
                        selectedIndex = (selectedIndex + length + direction) % length
                        selectedIndex += selectedIndex ? 0 : direction
                        if (selectedIndex < 0) selectedIndex = length - 1
                    }
                    let match = matches[selectedIndex]
                    if (Array.isArray(match)) {
                        selectedIndex = (selectedIndex + length + direction) % length
                        selectedIndex += selectedIndex ? 0 : direction
                        match = matches[selectedIndex]
                    }
                    if (match)
                        this.jumpTo(match)
                    return
                }
                const editor = g.activeEditor
                if (!editor) return
                const cm = editor.cm
                const query = this.getQuery()
                let searchCursor = cm.getSearchCursor(query,
                    direction > 0 ? cm.getCursor('to') : cm.getCursor('from'))
                const action = direction > 0 ? 'findNext' : 'findPrevious'
                let found = searchCursor[action]()

                if (!found) { // wrap around
                    searchCursor = cm.getSearchCursor(query,
                        direction > 0 ? Pos(cm.firstLine(), 0) : Pos(cm.lastLine()))
                    found = searchCursor[action]()
                }
                if (!found) {
                    g.notificationBar.show('warning', 'Not found.')
                    this.set({ selectedIndex: -1 })
                    return
                }

                let from = searchCursor.from()
                let to = searchCursor.to()
                const pos = { from, to }

                nextFrame(() => {
                    const { matches } = this.get()
                    const selectedIndex = matches.findIndex(x => x.from.line === from.line && x.from.ch === from.ch)
                    this.set({ selectedIndex })
                    this.clearSelections()
                })

                cm.operation(() => {
                    const changeObject = { textMark: cm.markText(from, to, textMarkOption) }
                    if (editor.get().highlightOverlay !== this.highlightOverlay) {
                        changeObject.highlightOverlay = this.highlightOverlay
                    }
                    editor.set(changeObject)
                    cm.setSelection(from, to)
                    cm.scrollIntoView(pos, 20)
                })
                return searchCursor
            },
            replace(direction) {
                const editor = g.activeEditor
                if (!editor) return
                const cm = editor.cm
                const { replaceText } = this.get()
                if (cm.somethingSelected()) {
                    cm.replaceSelection(replaceText)
                } else if (direction === 0) {
                    g.notificationBar.show('warning', 'Nothing selected to be replaced.')
                    return
                } else {
                    const searchCursor = this.findNext(direction)
                    if (!searchCursor) {
                        g.notificationBar.show('warning', 'No result found to be replaced.')
                        return
                    }
                    searchCursor.replace(replaceText)
                }
                const searchCursor = this.findNext(direction)
                if (!searchCursor)
                    g.notificationBar.show('warning', 'No result found.')
            },
            jumpTo(match) {
                g.panelMiddle.openFile(match.filePath, editor => {
                    const cm = setCursorAndScrollIntoView(match.from.line, match.from.ch)
                    cm.extendSelection(match.from, match.to)
                    editor.set({ highlightOverlay: null })
                })
                const { matches } = this.get()
                this.set({ selectedIndex: matches.indexOf(match) })
            },
            toggleSelection(match) {
                if (!g.activeEditor) return

                const { selectedMatches } = this.get()
                if (selectedMatches.has(match)) {
                    selectedMatches.delete(match)
                } else {
                    selectedMatches.add(match)
                }
                this.set({ selectedMatches })
            },
            clearSelections() {
                const { selectedMatches } = this.get()
                selectedMatches.clear()
                this.set({ selectedMatches })
            },
            selectAll() {
                if (!g.activeEditor) return

                let { selectedMatches, matches } = this.get()
                if (selectedMatches.size === matches.length) {
                    selectedMatches.clear()
                } else {
                    selectedMatches = new Set(matches)
                }
                this.set({ selectedMatches })
            },
            findInFile(editor) {
                cancelAnimationFrame(this.jobAnimationFrameId)
                const query = this.getQuery()
                if (query) {
                    const searchCursor = editor.cm.getSearchCursor(query, Pos(0, 0))
                    const filePath = editor.get().filePath
                    let found
                    const { matches } = this.get()
                    matches.length = 0

                    let limit = 30
                    const job = () => {
                        while (found = searchCursor.findNext()) {
                            const match = found[0]
                            const { length } = match
                            const { input, index } = found
                            const head = input.substring(0, index)
                            const tail = input.substring(index + length)
                            const from = searchCursor.from()
                            const to = searchCursor.to()
                            const display = `${head}<em>${match}</em>${tail}`
                            matches.push({ display, from, to, filePath })
                            if (matches.length === limit) {
                                limit += 100
                                this.jobAnimationFrameId = requestAnimationFrame(job)
                                break
                            }
                        }
                        this.set({ matches })
                    }
                    job()

                    this.highlightOverlay = searchOverlayGenerator(query)
                    nextFrame(() => {
                        editor.set({ highlightOverlay: this.highlightOverlay })
                    })
                } else {
                    editor.set({ highlightOverlay: null })
                }
            },
            findInDirectory(limit) {
                const { findInDirectory, findText, caseSensitive, regex, wholeWord, subdirectory } = this.get()
                if (!findText.length) {
                    this.set({
                        matches: [],
                        nFiles: 0,
                        overflow: false
                    })
                    return
                }
                if (!limit)
                    limit = findText.length > 1 ? 299 : 99
                let query = findText
                if (!regex) query = findText.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&')
                if (wholeWord) query = `\\b${query}\\b`
                g.projectSession.send('FindInDirectory', {
                    path: findInDirectory,
                    query,
                    limit,
                    caseSensitive,
                    subdirectory
                })
            },
        }
    }

</script>
