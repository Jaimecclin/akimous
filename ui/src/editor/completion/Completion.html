<div bind:this={container} class="completion non-selectable" class:gone="{!open}">
    {#if passive}
    <CompletionRow bind:this={passivePlaceholder} parent={null} type="instruction" rowNumber="â‡¥" highlight="Tab to commit the selected item"></CompletionRow>
    {/if}
    <div bind:this={completion}></div>
</div>

<style>
    .completion {
        position: absolute;
        height: 14rem;
        width: 28rem;
        z-index: 170;
        background: var(--main-bg-color);

        color: var(--monospace-font-color);
        white-space: nowrap;
        font-family: var(--monospace-font-family);
        font-size: var(--monospace-font-size);
        line-height: 2rem;

        overflow-x: scroll;
        border-radius: var(--default-radius);
        box-shadow: var(--default-shadow);
    }

</style>


<script>
    import { beforeUpdate, onMount } from 'svelte'
    
    import g from '../../lib/Globals'
    import CompletionRow from './CompletionRow.html'
    import EventDispatcherFactory from '../../LayeredKeyboardControl/EventDispatcherFactory'
    import { CLOSED, NORMAL } from './CompletionProvider'

    const EXTRA_PREDICTIONS = new Set([
        'word-segment',
        'word',
        'full-statement'
    ])

    export let open = false,
        passive = false,
        rows = [],
        selectedCompletionRow = null,
        closable = true
    
    let container,
        passivePlaceholder,
        completion,
        completionRows = [],
        completionRowShortcuts = new Array(9),
        cm,
        completionProvider
    
    let keyEventHandler = EventDispatcherFactory({
        // target: this,
        extraKeyHandler(event, target) {
            const { key } = event
            if (/[.,()[\]:+\-*/|&^~%@><!]/.test(key)) {
                target.enter(null, key)
            } else if (/[=[\](){}]/.test(key)) {
                target.set({
                    open: false
                })
                target.completionProvider.state = CLOSED
            } else if (key === 'Escape') {
                target.completionProvider.state = CLOSED
            }
            return true
        },
    })

    onMount(() => {
        // keep row number of visible rows 1 to 7
        let lastFVI = 999
        const scrollHandler = () => {
            const rowHeight = completionRows[0].refs.completionRow.clientHeight
            let firstVisibleIndex = Math.floor(container.scrollTop / rowHeight) - passive
            if (firstVisibleIndex < 0)
                firstVisibleIndex = 0
            if (firstVisibleIndex > completionRows.length)
                firstVisibleIndex = completionRows.length - 1
            if (lastFVI === firstVisibleIndex) return

            let lastVisibleIndex = firstVisibleIndex + 8
            if (lastVisibleIndex > completionRows.length)
                lastVisibleIndex = completionRows.length
            for (let i = firstVisibleIndex; i < lastVisibleIndex; i++) {
                const rowNumber = i - firstVisibleIndex + 1
                completionRows[i].set({ rowNumber })
                completionRowShortcuts[rowNumber] = completionRows[i]
            }
            lastFVI = firstVisibleIndex
        }
        container.addEventListener('scroll', scrollHandler, { passive: true })

//        __this.on('state', ({ changed, current }) => {
//            // Don't merge this with onstate, or the completion selection will break
//            if (changed.rows) {
//                const rows = current.rows
//                for (const row of __this.completionRows)
//                    row.destroy()
//                __this.completionRows.length = 0
//                if (rows.length === 0) return
//                for (const [i, row] of rows.entries()) {
//                    row.index = i
//                    row.rowNumber = i + 1
//                    row.parent = this
//                    const completionRow = new CompletionRow({
//                        target: completion,
//                        data: row
//                    })
//                    __this.completionRows.push(completionRow)
//                    __this.completionRowShortcuts[row.rowNumber] = completionRow
//                }
//                lastFVI = 999
//                selectedCompletionRow = this.completionRows[0]
//            }
//        })
        
        const oldCommandHandler = keyEventHandler.handleCommand
        const PASSTHROUGH_COMMANDS = new Set([
            'home', 'left', 'right', 'end', 'delGroupBefore', 'delGroupAfter',
        ])
        keyEventHandler.handleCommand = command => {
            if (PASSTHROUGH_COMMANDS.has(command)) return true
            oldCommandHandler(command)
        }
    })

    // [svelte-upgrade warning]
    // beforeUpdate and afterUpdate handlers behave
    // differently to their v2 counterparts
    beforeUpdate(() => {
        // Don't merge this with on('stat), or the completion selection will break
//        if (!previous) return
//        if (changed.open) {
//            if (current.open) g.pushFocus(this)
//            else {
//                g.popFocus(this)
//                g.docs.set({ completionDoc: null })
//            }
//        }
//        if (changed.selectedCompletionRow) {
//            if (previous.selectedCompletionRow) previous.selectedCompletionRow.set({
//                selected: false
//            })
//            if (current.selectedCompletionRow) current.selectedCompletionRow.set({
//                selected: true
//            })
//        }
//        if (changed.open && !current.open)
//            __this.completionProvider.state = CLOSED
    })

    // [svelte-upgrade suggestion]
    // review these functions and remove unnecessary 'export' keywords
    export function bindReferences(editor) {
        cm = editor.cm
        completionProvider = editor.completionProvider
    }

    export function requestCompletionDocstringIfNeeded(completion) {
        let name = completion.completion
        if (name === lastRequestedCompletionForDocstring) return
        if (EXTRA_PREDICTIONS.has(completion.type))
            return // don't request docstring if it is not actually a completion

        // remove redundant punctuation
        const match = name.match(/^[^\d\W]\w*/)
        if (match)
            name = match[0]
        lastRequestedCompletionForDocstring = name
        editor.session.send('GetCompletionDocstring', { name })
    }

    export function setCompletions(rows, firstTriggeredCharPos, type) {
        const passive = type !== NORMAL
        if (!rows.length) {
            open = false
        } else {
            open = true
            repositionCompletionWindow(firstTriggeredCharPos)
            requestCompletionDocstringIfNeeded(rows[0])
        }
    }

    export function repositionCompletionWindow(pos) {
        if (!open)
            return
        const editorElement = editor.refs.codeEditor
        const container = container

        const rem = parseFloat(getComputedStyle(document.documentElement).fontSize)
        const coords = cm.charCoords(pos, 'window')
        const charHeight = coords.bottom - coords.top

        const editorArea = editorElement.getBoundingClientRect()
        const completionArea = container.getBoundingClientRect()
        const completionHeight = completionArea.bottom - completionArea.top

        let x = coords.left - editorArea.left - 3 * rem
        let y = coords.bottom - editorArea.top + 1.6 * charHeight
        if (y + completionHeight > editorArea.bottom) {
            y = coords.top - completionHeight - 1.6 * charHeight
        }
        container.style.left = `${x}px`
        container.style.top = `${y}px`
    }

    export function enter(rowNumber, key) {
        if (!open) return console.error('closed')
        const row = rowNumber ? completionRowShortcuts[rowNumber] : selectedCompletionRow
        if (!row) return console.error('no selected completion')

        completionProvider.state = CLOSED
        let { text, tail } = row.get()
        text = text + tail
        open = false

        // Don't commit passive completions unless the key is Tab or a number.
        if (passive && !/\d/.test(key) && key !== 'Tab') {
            if (key === 'commit') {
                const cursor = cm.doc.getCursor()
                cm.replaceRange(' ', cursor, cursor, '+input')
            }
            return true // let it propagate
        }

        cm.replaceRange(
            text,
            completionProvider.firstTriggeredCharPos,
            cm.doc.getCursor(),
            '+completion'
        )
        if (tail === '()')
            cm.execCommand('goCharLeft')
        cm.focus()
    }

    export function move(nRows) {
        const currentIndex = selectedCompletionRow.index
        const length = completionRows.length

        let targetIndex = currentIndex + nRows
        if (targetIndex >= length) targetIndex = length - 1
        else if (targetIndex < 0) targetIndex = 0

        const targetRow = completionRows[targetIndex]
        requestCompletionDocstringIfNeeded(targetRow.get())
        selectedCompletionRow = targetRow
        targetRow.refs.completionRow.scrollIntoViewIfNeeded(false)
    }
</script>
