<script>
    import { beforeUpdate, onMount } from 'svelte';

    // [svelte-upgrade suggestion]
    // manually refactor all references to __this
    const __this = {
        get: () => ({ open, passive, rows, selectedCompletionRow, closable })
    };

    export let container;
    export let passivePlaceholder;
    export let completion;

    import g from '../../lib/Globals'
    import CompletionRow from './CompletionRow.html'
    import EventDispatcherFactory from '../../LayeredKeyboardControl/EventDispatcherFactory'
    import { CLOSED, NORMAL } from './CompletionProvider'

    const EXTRA_PREDICTIONS = new Set([
        'word-segment',
        'word',
        'full-statement'
    ])

    export let open = false;
    export let passive = false;
    export let rows = [];
    export let selectedCompletionRow = null;
    export let closable = true;

    onMount(() => {
        __this.completionRows = []
        __this.completionRowShortcuts = new Array(9)

        // keep row number of visible rows 1 to 7
        let lastFVI = 999
        const scrollHandler = () => {
            const rowHeight = __this.completionRows[0].refs.completionRow.clientHeight
            let firstVisibleIndex = Math.floor(container.scrollTop / rowHeight) - passive
            if (firstVisibleIndex < 0)
                firstVisibleIndex = 0
            if (firstVisibleIndex > __this.completionRows.length)
                firstVisibleIndex = __this.completionRows.length - 1
            if (lastFVI === firstVisibleIndex) return

            let lastVisibleIndex = firstVisibleIndex + 8
            if (lastVisibleIndex > __this.completionRows.length)
                lastVisibleIndex = __this.completionRows.length
            for (let i = firstVisibleIndex; i < lastVisibleIndex; i++) {
                const rowNumber = i - firstVisibleIndex + 1
                __this.completionRows[i].set({
                    rowNumber
                })
                __this.completionRowShortcuts[rowNumber] = __this.completionRows[i]
            }
            lastFVI = firstVisibleIndex
        }
        container.addEventListener('scroll', scrollHandler, {
            passive: true
        })

//        __this.on('state', ({ changed, current }) => {
//            // Don't merge this with onstate, or the completion selection will break
//            if (changed.rows) {
//                const rows = current.rows
//                for (const row of __this.completionRows)
//                    row.destroy()
//                __this.completionRows.length = 0
//                if (rows.length === 0) return
//                for (const [i, row] of rows.entries()) {
//                    row.index = i
//                    row.rowNumber = i + 1
//                    row.parent = this
//                    const completionRow = new CompletionRow({
//                        target: completion,
//                        data: row
//                    })
//                    __this.completionRows.push(completionRow)
//                    __this.completionRowShortcuts[row.rowNumber] = completionRow
//                }
//                lastFVI = 999
//                selectedCompletionRow = this.completionRows[0]
//            }
//        })

        __this.keyEventHandler = EventDispatcherFactory({
            target: this,
            extraKeyHandler(event, target) {
                const { key } = event
                if (/[.,()[\]:+\-*/|&^~%@><!]/.test(key)) {
                    target.enter(null, key)
                } else if (/[=[\](){}]/.test(key)) {
                    target.set({
                        open: false
                    })
                    target.completionProvider.state = CLOSED
                } else if (key === 'Escape') {
                    target.completionProvider.state = CLOSED
                }
                return true
            },
        })
        
        const oldCommandHandler = __this.keyEventHandler.handleCommand
        const PASSTHROUGH_COMMANDS = new Set([
            'home', 'left', 'right', 'end', 'delGroupBefore', 'delGroupAfter',
        ])
        __this.keyEventHandler.handleCommand = command => {
            if (PASSTHROUGH_COMMANDS.has(command)) return true
            oldCommandHandler(command)
        }
    });

    // [svelte-upgrade warning]
    // beforeUpdate and afterUpdate handlers behave
    // differently to their v2 counterparts
    beforeUpdate(() => {
        // Don't merge this with on('stat), or the completion selection will break
//        if (!previous) return
//        if (changed.open) {
//            if (current.open) g.pushFocus(this)
//            else {
//                g.popFocus(this)
//                g.docs.set({ completionDoc: null })
//            }
//        }
//        if (changed.selectedCompletionRow) {
//            if (previous.selectedCompletionRow) previous.selectedCompletionRow.set({
//                selected: false
//            })
//            if (current.selectedCompletionRow) current.selectedCompletionRow.set({
//                selected: true
//            })
//        }
//        if (changed.open && !current.open)
//            __this.completionProvider.state = CLOSED
    });

    // [svelte-upgrade suggestion]
    // review these functions and remove unnecessary 'export' keywords
    export function bindReferences(editor) {
        __this.editor = editor
        __this.cm = editor.cm
        __this.completionProvider = editor.completionProvider
    }

    export function requestCompletionDocstringIfNeeded(completion) {
        let name = completion.completion
        if (name === __this.lastRequestedCompletionForDocstring) return
        if (EXTRA_PREDICTIONS.has(completion.type))
            return // don't request docstring if it is not actually a completion

        // remove redundant punctuation
        const match = name.match(/^[^\d\W]\w*/)
        if (match)
            name = match[0]
        __this.lastRequestedCompletionForDocstring = name
        __this.editor.session.send('GetCompletionDocstring', { name })
    }

    export function setCompletions(rows, firstTriggeredCharPos, type) {
        const passive = type !== NORMAL
        if (!rows.length) {
            open = false
        } else {
            open = true
            repositionCompletionWindow(firstTriggeredCharPos)
            requestCompletionDocstringIfNeeded(rows[0])
        }
    }

    export function repositionCompletionWindow(pos) {
        if (!__this.get().open)
            return
        const editorElement = __this.editor.refs.codeEditor
        const container = container

        const rem = parseFloat(getComputedStyle(document.documentElement).fontSize)
        const coords = __this.cm.charCoords(pos, 'window')
        const charHeight = coords.bottom - coords.top

        const editorArea = editorElement.getBoundingClientRect()
        const completionArea = container.getBoundingClientRect()
        const completionHeight = completionArea.bottom - completionArea.top

        let x = coords.left - editorArea.left - 3 * rem
        let y = coords.bottom - editorArea.top + 1.6 * charHeight
        if (y + completionHeight > editorArea.bottom) {
            y = coords.top - completionHeight - 1.6 * charHeight
        }
        container.style.left = `${x}px`
        container.style.top = `${y}px`
    }

    export function enter(rowNumber, key) {
        if (!open) return console.error('closed')
        const row = rowNumber ? __this.completionRowShortcuts[rowNumber] : __this.get().selectedCompletionRow
        if (!row) return console.error('no selected completion')

        __this.completionProvider.state = CLOSED
        let { text, tail } = row.get()
        text = text + tail
        open = false

        // Don't commit passive completions unless the key is Tab or a number.
        if (passive && !/\d/.test(key) && key !== 'Tab') {
            if (key === 'commit') {
                const cursor = __this.cm.doc.getCursor()
                __this.cm.replaceRange(' ', cursor, cursor, '+input')
            }
            return true // let it propagate
        }

        __this.cm.replaceRange(
            text,
            __this.completionProvider.firstTriggeredCharPos,
            __this.cm.doc.getCursor(),
            '+completion'
        )
        if (tail === '()')
            __this.cm.execCommand('goCharLeft')
        __this.cm.focus()
    }

    export function move(nRows) {
        const currentIndex = __this.get().selectedCompletionRow.get().index
        const length = __this.completionRows.length

        let targetIndex = currentIndex + nRows
        if (targetIndex >= length) targetIndex = length - 1
        else if (targetIndex < 0) targetIndex = 0

        const targetRow = __this.completionRows[targetIndex]
        requestCompletionDocstringIfNeeded(targetRow.get())
        selectedCompletionRow = targetRow
        targetRow.refs.completionRow.scrollIntoViewIfNeeded(false)
    }
</script>

<div bind:this={container} class="completion non-selectable" class:gone="{!open}">
    {#if passive}
    <CompletionRow bind:this={passivePlaceholder} parent={null} type="instruction" rowNumber="â‡¥" highlight="Tab to commit the selected item"></CompletionRow>
    {/if}
    <div bind:this={completion}></div>
</div>

<style>
    .completion {
        position: absolute;
        height: 14rem;
        width: 28rem;
        z-index: 170;
        background: var(--main-bg-color);

        color: var(--monospace-font-color);
        white-space: nowrap;
        font-family: var(--monospace-font-family);
        font-size: var(--monospace-font-size);
        line-height: 2rem;

        overflow-x: scroll;
        border-radius: var(--default-radius);
        box-shadow: var(--default-shadow);
    }

</style>
