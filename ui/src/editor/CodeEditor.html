<div ref:codeEditor class="tab-view" class:hideTextSelection="highlightOverlay" class:gone="!active" />
<Completion ref:completion></Completion>


<style>
    :global(.hideTextSelection .CodeMirror-selected) {
        display: none;
    }

</style>


<script>
    import g from '../lib/Globals'
    import CMEventDispatcher from './CMEventDispatcher'
    import registerCMCommands from './CMCommands'
    import RealtimeFormatter from './RealtimeFormatter'
    import { CompletionProvider } from './completion/CompletionProvider'
    import { getIconByFileName } from '../lib/FileTypeToIcon'
    import { schedule, nextFrame, joinPath } from '../lib/Utils'

    /* eslint-disable */
    import CodeMirror from 'codemirror'
    import python from './python'

    // CM modes
    import clike from 'codemirror/mode/clike/clike'
    import cmake from 'codemirror/mode/cmake/cmake'
    import css from 'codemirror/mode/css/css'
    import django from 'codemirror/mode/django/django'
    import dockerfile from 'codemirror/mode/dockerfile/dockerfile'
    import go from 'codemirror/mode/go/go'
    import htmlembedded from 'codemirror/mode/htmlembedded/htmlembedded'
    import htmlmixed from 'codemirror/mode/htmlmixed/htmlmixed'
    import javascript from 'codemirror/mode/javascript/javascript'
    import lua from 'codemirror/mode/lua/lua'
    import markdown from 'codemirror/mode/markdown/markdown'
    import nginx from 'codemirror/mode/nginx/nginx'
    import perl from 'codemirror/mode/perl/perl'
    import php from 'codemirror/mode/php/php'
    import protobuf from 'codemirror/mode/protobuf/protobuf'
    import r from 'codemirror/mode/r/r'
    import ruby from 'codemirror/mode/ruby/ruby'
    import rust from 'codemirror/mode/rust/rust'
    import sass from 'codemirror/mode/sass/sass'
    import shell from 'codemirror/mode/shell/shell'
    import sql from 'codemirror/mode/sql/sql'
    import swift from 'codemirror/mode/swift/swift'
    import toml from 'codemirror/mode/toml/toml'
    import xml from 'codemirror/mode/xml/xml'
    import yaml from 'codemirror/mode/yaml/yaml'


    // CM addons
    import meta from 'codemirror/mode/meta'
    import matchbrackets from 'codemirror/addon/edit/matchbrackets'
    import closebrackets from 'codemirror/addon/edit/closebrackets'
    import comment from 'codemirror/addon/comment/comment'
    import activeline from 'codemirror/addon/selection/active-line'
    import searchcursor from 'codemirror/addon/search/searchcursor'
    // TODO: current code folding implementation (especially fold gutter) may cause performance problems
    import foldcode from 'codemirror/addon/fold/foldcode'
    import foldgutter from 'codemirror/addon/fold/foldgutter'
    import indentFold from 'codemirror/addon/fold/indent-fold'
    import sublime from 'codemirror/keymap/sublime'

    import matchhighlighter from './match-highlighter'
    /* eslint-enable */

    g.CodeMirror = CodeMirror

    registerCMCommands(CodeMirror)
    const overlayOption = {
        opaque: true,
        priority: 0,
    }

    export default {
        components: {
            Completion: './completion/Completion.html'
        },
        oncreate() {
            this.parent = this.get().parent
            this.saving = false
            this.offlineLints = []
            this.realtimeLints = []
            this.spellingErrors = []
            this.outline = []
            g.linter.clear()

            const { fileName } = this.get()
            this.tab = this.parent.tabBar.openTab(this, fileName, getIconByFileName(fileName))
            g.panelMiddle.pathToEditor[joinPath(this.get().filePath)] = this

            const mode = CodeMirror.findModeByFileName(fileName)

            // Step 1: Connect to websocket and read file
            const readFile = new Promise(resolve => {
                let startTime = performance.now()
                this.shouldClose = false
                this.completion = this.refs.completion

                this.session = g.socket.createSession('editor', {
                    filePath: this.get().filePath
                })
                Object.assign(this.session.handlers, {
                    FileOpened: data => {
                        console.debug('transmission took', performance.now() - startTime)
                        resolve(data) // <-- exit here
                    },
                    FailedToOpen: reason => {
                        g.notificationBar.show('warning', reason)
                        g.panelMiddle.closeFile(this.get().filePath)
                    },
                    RealTimeLints: ({ result }) => {
                        this.realtimeLints = result
                        if (g.activeEditor === this)
                            g.linter.set({ realtimeLints: this.realtimeLints })
                    },
                    FileSaved: data => {
                        this.mtime = data.mtime
                        this.saving = false
                        if (this.shouldClose)
                            g.panelMiddle.closeFile(this.get().filePath)
                        else if (data.content) {
                            this.cm.setValue(data.content)
                            if (this.cursorBeforeSaving) {
                                // restore cursor and viewport position in case formatter changes the content
                                this.cm.setCursor(this.cursorBeforeSaving)
                                this.cm.scrollTo(this.scrollInfoBeforeSaving.left, this.scrollInfoBeforeSaving.top)
                            }
                        }
                        if (!this.shouldClose)
                            this.markClean()
                        let message = `"<b>${this.get().fileName}</b>"`
                        message += data.content ? ' formatted and saved.' : ' saved.'
                        g.notificationBar.show('success', message)
                    },
                    Reloaded: data => {
                        // prompt to reload if modified by another program
                        this.cm.setValue(data.content)
                        this.markClean()
                    },
                    Mtime: data => {
                        if (this.mtime === data.mtime || this.saving) return
                        this.mtime = data.mtime
                        g.notificationBar.show(
                            'question',
                            `The file "<b>${this.get().fileName}</b>" has been modified by another program. Do you want to reload it?`, [{
                                name: 'Reload',
                                callback: () => this.session.send('Reload', {})
                            }]
                        )
                    },
                    FileDeleted: () => {
                        if (this.saving) return
                        // prompt to close if deleted or moved
                        g.notificationBar.show(
                            'question',
                            `The file "<b>${this.get().fileName}</b>" has been deleted or moved to another place. Do you want to close it?`, [{
                                name: 'Close',
                                callback: () => {
                                    this.markClean()
                                    g.panelMiddle.closeFile(this.get().filePath)
                                }
                            }]
                        )
                    },
                    CompletionDocstring: ({ doc, type }) => {
                        if (doc.length === 0) doc = null
                        g.docs.set({ completionDoc: doc, completionDocType: type })
                    },
                    FunctionDocumentation: ({ doc, type }) => {
                        if (doc.length === 0) doc = null
                        g.docs.set({ functionDoc: doc, functionDocType: type })
                        g.docs.highlightActiveParameter(this.cm)
                    },
                    OfflineLints: data => {
                        this.offlineLints = data.result
                        this.offlineLints.sort((a, b) => (a.line - b.line) * 1000 + (a.column - b.column))
                        this.offlineLints.forEach(x => {
                            const { message } = x
                            const index = message.indexOf('\n')
                            if (index <= 0) {
                                x.message0 = message
                                x.message1 = ''
                            } else {
                                x.message0 = message.substring(0, index)
                                x.message1 = message.substring(index + 1)
                            }
                        })
                        if (g.activeEditor === this)
                            g.linter.set({ offlineLints: this.offlineLints })
                    },
                    SpellingErrors: data => {
                        this.spellingErrors = data.result
                        if (g.activeEditor === this)
                            g.linter.set({ spellingErrors: this.spellingErrors })
                    },
                    ReferencesFound: data => {
                        g.references.set(data)
                        g.panelRight.activateView(g.references)
                    },
                })
            })

            // Step 2: Open editor
            this.highlightSelectionMatches = { // search/match-highlighter
                style: 'match-highlight',
                minChars: 1,
                delay: 50,
                wordsOnly: false,
                annotateScrollbar: false,
                showToken: false,
                trim: false
            }
            const initializeCM = readFile.then(data => {
                const { indentWithTabs, indentSize } = g.cursorPosition.get()
                this.cm = CodeMirror(this.refs.codeEditor, {
                    value: data.content,
                    mode: mode ? mode.mime : undefined,
                    theme: 'akimous',
                    indentUnit: indentSize,
                    indentWithTabs: indentWithTabs,
                    lineNumbers: true,
                    autofocus: true,
                    viewportMargin: 20,

                    // addons
                    matchBrackets: true, // edit/matchbrackets
                    autoCloseBrackets: true, // edit/closebrackets
                    highlightSelectionMatches: this.highlightSelectionMatches,
                    styleActiveLine: true, // selection/active-line

                    foldGutter: true, // fold/foldgutter
                    gutters: ['padding-gutter', 'CodeMirror-foldgutter', 'CodeMirror-linenumbers'],

                    // keymap
                    /* eslint-disable */
                    extraKeys: {
                        'Tab': 'indentMore',
                        'Shift-Tab': 'indentLess',
                        'Cmd-/': 'toggleCommentIndented',
                        'Cmd-Backspace': 'deleteLineAndGoUp',
                        'Cmd-Delete': 'deleteLineAndGoDown',
                        'Cmd-D': 'duplicateLine',
                        'Cmd-J': 'joinLines',
                        'Cmd-B': 'selectNextOccurrence',

                        'Ctrl-Left': 'goSubwordLeft', // should implement on LKC
                        'Ctrl-Right': 'goSubwordRight', // should implement on LKC
                        'Cmd-L': 'splitSelectionByLine', // change not visible, need modification
                        'Esc': 'singleSelectionTop',
                        'Cmd-Enter': 'moveToLineEndAndInsertLineAfter',
                        'Shift-Cmd-Enter': 'insertLineBefore',
                        'Backspace': 'smartBackspace',

                        "Shift-Cmd-Backspace": "delLineLeft",
                        "Shift-Cmd-Delete": "delLineRight",
                        "Cmd-Alt-Up": "addCursorToPrevLine",
                        "Cmd-Alt-Down": "addCursorToNextLine",
                    }
                    /* eslint-enable */
                })
                this.mtime = data.mtime
            })

            // Step 3: Do the rest of things (about 20 ms)
            initializeCM.then(() => schedule(() => {
                this.cm.refresh() // prevent CM occasionally shifts to the right
                this.completionProvider = new CompletionProvider(this)
                // only enable completionProvider when the document is a Python file
                if (mode && mode.mode !== 'python') {
                    this.completionProvider.enabled = false
                }
                this.realtimeFormatter = RealtimeFormatter(this, CodeMirror)
                this.cmEventDispatcher = new CMEventDispatcher(this)
                this.completion.bindReferences(this)

                // resolve Safari over-scroll jitter issue
                const scroller = this.refs.codeEditor.getElementsByClassName('CodeMirror-scroll')[0]
                scroller.onwheel = e => {
                    if (e.deltaY <= 0) return
                    const scrollInfo = this.cm.getScrollInfo()
                    if (scrollInfo.top + scrollInfo.clientHeight >= scrollInfo.height) {
                        e.preventDefault()
                    }
                }
                if (this.cmReadyCallback) {
                    this.cmReadyCallback(this)
                    this.cmReadyCallback = null
                }

                schedule(() => {
                    this.outline = g.outline.generateOutline(this.cm)
                    if (g.activeEditor === this)
                        g.outline.set({ outlineItems: this.outline })
                })
            }))
        },
        ondestroy() {
            this.tab.destroy()
            g.linter.clear()
            delete g.panelMiddle.pathToEditor[joinPath(this.get().filePath)]
            this.session.send('Close')
            this.session.close()
        },
        onstate({ changed, current, previous }) {
            if (!previous) return
            if (changed.filePath) {
                const newPath = current.filePath
                g.panelMiddle.pathToEditor[joinPath(newPath)] = this
                if (previous.filePath) {
                    delete g.panelMiddle.pathToEditor[joinPath(previous.filePath)]
                    this.session.send('Mtime', { newPath })
                }
            }
            const tab = this.tab
            if (!tab) return

            if (changed.fileName) {
                tab.set({ name: current.fileName })
            }
            if (changed.clean) {
                tab.set({ clean: current.clean })
            }
            if (changed.active) {
                const { active } = current
                const { cm } = this
                tab.set({ active: active })
                if (active && this.session && cm) {
                    nextFrame(() => {
                        // content may not show for background editors if multiple editors are opened during startup
                        cm.refresh()
                        this.session.send('ActivateEditor')
                    })

                }
            }
            if (changed.highlightOverlay) {
                const { cm } = this
                cm.removeOverlay(previous.highlightOverlay)
                if (current.highlightOverlay && !cm.hasFocus()) {
                    cm.setOption('highlightSelectionMatches', false) // pause highlightSelectionMatches
                    cm.addOverlay(current.highlightOverlay, overlayOption)
                } else { // resume highlightSelectionMatches
                    const currentOption = cm.getOption('highlightSelectionMatches')
                    if (this.highlightSelectionMatches !== currentOption)
                        cm.setOption('highlightSelectionMatches', this.highlightSelectionMatches)
                }
            }
            if (changed.textMark && previous.textMark) {
                previous.textMark.clear()
            }
        },
        data() {
            return {
                fileName: '',
                filePath: null,
                active: false,
                clean: true,
                highlightOverlay: null,
                textMark: null,
            }
        },
        computed: {
            isMakefile: ({ fileName }) => fileName.toLowerCase() === 'makefile'
        },
        methods: {
            save() {
                this.saving = true
                this.session.send('SaveFile', { content: this.cm.getValue() })
                // preserve cursor and viewport position in case formatter changes the content
                this.cursorBeforeSaving = this.cm.getCursor()
                this.scrollInfoBeforeSaving = this.cm.getScrollInfo()
            },
            insertText(text) {
                g.activeEditor && g.activeEditor.cm.hasFocus()
                if (g.activeEditor != this || !this.cm.hasFocus()) return
                this.cm.doc.replaceRange(text, this.cm.doc.getCursor('from'), this.cm.doc.getCursor('to'), '+input')
            },
            markClean() {
                this.set({ clean: true })
                this.cm.doc.markClean()
            },
            syncChanges(changes, lineContent) {
                if (!this.completionProvider.enabled) return
                const { cm } = this
                if (!lineContent)
                    for (let c = 0; c < changes.length; c++) {
                        const change = changes[c]
                        const { text, removed } = change
                        const from = change.from.line
                        const to = change.to.line

                        let lint = text.length > 1 || removed.length > 1
                        if (c != changes.length - 1) lint = false // only lint on last change

                        text[0] = cm.getLine(from)
                        if (to != from && to - from === text.length - 1)
                            text[text.length - 1] = cm.getLine(to)

                        this.session.send('SyncRange', [from, to + 1, lint, ...text])
                    }
                else {
                    this.session.send('SyncRange', [changes, changes + 1, true, lineContent])
                }
                schedule(() => {
                    this.outline = g.outline.generateOutline(this.cm)
                    if (g.activeEditor === this)
                        g.outline.set({
                            outlineItems: this.outline,
                            currentLine: this.cm.getCursor().line
                        })
                })
            }
        }
    }

</script>
