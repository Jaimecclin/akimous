<div bind:this={codeEditor} class="tab-view" class:hideTextSelection="{highlightOverlay}" class:gone="{!active}" />
<!--<Completion bind:this={completion}></Completion>-->


<style>
    :global(.hideTextSelection .CodeMirror-selected) {
        display: none;
    }

</style>

<script>
    import { beforeUpdate, onDestroy, onMount, createEventDispatcher } from 'svelte'

    import g from '../lib/Globals'
    import CMEventDispatcher from './CMEventDispatcher'
    import registerCMCommands from './CMCommands'
    import RealtimeFormatter from './RealtimeFormatter'
    import { CompletionProvider } from './completion/CompletionProvider'
    import { getIconByFileName } from '../lib/FileTypeToIcon'
    import { schedule, nextFrame, joinPath } from '../lib/Utils'
    
    import Completion from './completion/Completion.html'

    /* eslint-disable */
    import CodeMirror from 'codemirror'
    import python from './python'

    // CM modes
    import clike from 'codemirror/mode/clike/clike'
    import cmake from 'codemirror/mode/cmake/cmake'
    import css from 'codemirror/mode/css/css'
    import django from 'codemirror/mode/django/django'
    import dockerfile from 'codemirror/mode/dockerfile/dockerfile'
    import go from 'codemirror/mode/go/go'
    import htmlembedded from 'codemirror/mode/htmlembedded/htmlembedded'
    import htmlmixed from 'codemirror/mode/htmlmixed/htmlmixed'
    import javascript from 'codemirror/mode/javascript/javascript'
    import lua from 'codemirror/mode/lua/lua'
    import markdown from 'codemirror/mode/markdown/markdown'
    import nginx from 'codemirror/mode/nginx/nginx'
    import perl from 'codemirror/mode/perl/perl'
    import php from 'codemirror/mode/php/php'
    import protobuf from 'codemirror/mode/protobuf/protobuf'
    import r from 'codemirror/mode/r/r'
    import ruby from 'codemirror/mode/ruby/ruby'
    import rust from 'codemirror/mode/rust/rust'
    import sass from 'codemirror/mode/sass/sass'
    import shell from 'codemirror/mode/shell/shell'
    import sql from 'codemirror/mode/sql/sql'
    import swift from 'codemirror/mode/swift/swift'
    import toml from 'codemirror/mode/toml/toml'
    import xml from 'codemirror/mode/xml/xml'
    import yaml from 'codemirror/mode/yaml/yaml'

    // CM addons
    import meta from 'codemirror/mode/meta'
    import matchbrackets from 'codemirror/addon/edit/matchbrackets'
    import closebrackets from 'codemirror/addon/edit/closebrackets'
    import comment from 'codemirror/addon/comment/comment'
    import activeline from 'codemirror/addon/selection/active-line'
    import searchcursor from 'codemirror/addon/search/searchcursor'
    // TODO: current code folding implementation (especially fold gutter) may cause performance problems
    import foldcode from 'codemirror/addon/fold/foldcode'
    import foldgutter from 'codemirror/addon/fold/foldgutter'
    import indentFold from 'codemirror/addon/fold/indent-fold'
    import sublime from 'codemirror/keymap/sublime'

    import matchhighlighter from './match-highlighter'
    /* eslint-enable */

    // [svelte-upgrade suggestion]
    // manually refactor all references to __this
    const __this = {
        get: () => ({ fileName, highlightOverlay, active, filePath, clean, textMark })
    }
    const dispatch = createEventDispatcher()
    
    g.CodeMirror = CodeMirror
        
    export let fileName = '',
        highlightOverlay = null,
        active = false,
        filePath = null,
        clean = true,
        textMark = null,
        pathString,
        uid
    
    let codeEditor,
        completion,
        cm,
        mtime
    
    $: {
        dispatch('active', {
            id: joinPath(filePath),
            active
        })
    }

    registerCMCommands(CodeMirror)
    const overlayOption = {
        opaque: true,
        priority: 0,
    }

    onMount(() => {
        __this.parent = __this.get().parent
        __this.saving = false
        __this.offlineLints = []
        __this.realtimeLints = []
        __this.spellingErrors = []
        __this.outline = []
//        g.linter.clear()
//        __this.tab = __this.parent.tabBar.openTab(this, fileName, getIconByFileName(fileName))
//        g.panelMiddle.pathToEditor[joinPath(__this.get().filePath)] = this
        const mode = CodeMirror.findModeByFileName(fileName)

        // Step 1: Connect to websocket and read file
        const readFile = new Promise(resolve => {
            let startTime = performance.now()
            __this.shouldClose = false
            __this.completion = completion

            __this.session = g.socket.createSession('editor', {
                filePath: __this.get().filePath
            })
            Object.assign(__this.session.handlers, {
                FileOpened: data => {
                    console.debug('transmission took', performance.now() - startTime)
                    resolve(data) // <-- exit here
                },
                FailedToOpen: reason => {
                    g.notificationBar.show('warning', reason)
                    g.panelMiddle.closeFile(__this.get().filePath)
                },
                RealTimeLints: ({ result }) => {
                    __this.realtimeLints = result
//                    if (g.activeEditor === this)
//                        g.linter.set({ realtimeLints: __this.realtimeLints })
                },
                FileSaved: data => {
                    __this.mtime = data.mtime
                    __this.saving = false
                    if (__this.shouldClose)
                        g.panelMiddle.closeFile(__this.get().filePath)
                    else if (data.content) {
                        __this.cm.setValue(data.content)
                        if (__this.cursorBeforeSaving) {
                            // restore cursor and viewport position in case formatter changes the content
                            __this.cm.setCursor(__this.cursorBeforeSaving)
                            __this.cm.scrollTo(__this.scrollInfoBeforeSaving.left, __this.scrollInfoBeforeSaving.top)
                        }
                    }
                    if (!__this.shouldClose)
                        markClean()
                    let message = `"<b>${__this.get().fileName}</b>"`
                    message += data.content ? ' formatted and saved.' : ' saved.'
                    g.notificationBar.show('success', message)
                },
                Reloaded: data => {
                    // prompt to reload if modified by another program
                    __this.cm.setValue(data.content)
                    markClean()
                },
                Mtime: data => {
                    if (__this.mtime === data.mtime || __this.saving) return
                    __this.mtime = data.mtime
                    g.notificationBar.show(
                        'question',
                        `The file "<b>${__this.get().fileName}</b>" has been modified by another program. Do you want to reload it?`, [{
                            name: 'Reload',
                            callback: () => __this.session.send('Reload', {})
                        }]
                    )
                },
                FileDeleted: () => {
                    if (__this.saving) return
                    // prompt to close if deleted or moved
                    g.notificationBar.show(
                        'question',
                        `The file "<b>${__this.get().fileName}</b>" has been deleted or moved to another place. Do you want to close it?`, [{
                            name: 'Close',
                            callback: () => {
                                markClean()
                                g.panelMiddle.closeFile(__this.get().filePath)
                            }
                        }]
                    )
                },
                CompletionDocstring: ({ doc, type }) => {
                    if (doc.length === 0) doc = null
                    g.docs.set({ completionDoc: doc, completionDocType: type })
                },
                FunctionDocumentation: ({ doc, type }) => {
                    if (doc.length === 0) doc = null
                    g.docs.set({ functionDoc: doc, functionDocType: type })
                    g.docs.highlightActiveParameter(__this.cm)
                },
                OfflineLints: data => {
                    __this.offlineLints = data.result
                    __this.offlineLints.sort((a, b) => (a.line - b.line) * 1000 + (a.column - b.column))
                    __this.offlineLints.forEach(x => {
                        const { message } = x
                        const index = message.indexOf('\n')
                        if (index <= 0) {
                            x.message0 = message
                            x.message1 = ''
                        } else {
                            x.message0 = message.substring(0, index)
                            x.message1 = message.substring(index + 1)
                        }
                    })
                    if (g.activeEditor === this)
                        g.linter.set({ offlineLints: __this.offlineLints })
                },
                SpellingErrors: data => {
                    __this.spellingErrors = data.result
//                    if (g.activeEditor === this)
//                        g.linter.set({ spellingErrors: __this.spellingErrors })
                },
                ReferencesFound: data => {
                    g.references.set(data)
                    g.panelRight.activateView(g.references)
                },
                RequestFullSync: () => {
                    __this.session.send('SyncRange', [0, __this.cm.lineCount(), false, 
                        ...g.activeEditor.cm.getValue().split('\n')])
                }
            })
        })

        // Step 2: Open editor
        __this.highlightSelectionMatches = { // search/match-highlighter
            style: 'match-highlight',
            minChars: 1,
            delay: 50,
            wordsOnly: false,
            annotateScrollbar: false,
            showToken: false,
            trim: false
        }
        const initializeCM = readFile.then(data => {
//            const { indentWithTabs, indentSize } = g.cursorPosition.get()
            cm = CodeMirror(codeEditor, {
                value: data.content,
                mode: mode ? mode.mime : undefined,
                theme: 'akimous',
//                indentUnit: indentSize,
//                indentWithTabs: indentWithTabs,
                lineNumbers: true,
                autofocus: true,
                viewportMargin: 20,

                // addons
                matchBrackets: true, // edit/matchbrackets
                autoCloseBrackets: true, // edit/closebrackets
                highlightSelectionMatches: __this.highlightSelectionMatches,
                styleActiveLine: true, // selection/active-line

                foldGutter: true, // fold/foldgutter
                gutters: ['padding-gutter', 'CodeMirror-foldgutter', 'CodeMirror-linenumbers'],

                // keymap
                /* eslint-disable */
                extraKeys: {
                    'Tab': 'indentMore',
                    'Shift-Tab': 'indentLess',
                    'Cmd-/': 'toggleCommentIndented',
                    'Cmd-Backspace': 'deleteLineAndGoUp',
                    'Cmd-Delete': 'deleteLineAndGoDown',
                    'Cmd-D': 'duplicateLine',
                    'Cmd-J': 'joinLines',
                    'Cmd-B': 'selectNextOccurrence',

                    'Ctrl-Left': 'goSubwordLeft', // should implement on LKC
                    'Ctrl-Right': 'goSubwordRight', // should implement on LKC
                    'Cmd-L': 'splitSelectionByLine', // change not visible, need modification
                    'Esc': 'singleSelectionTop',
                    'Cmd-Enter': 'moveToLineEndAndInsertLineAfter',
                    'Shift-Cmd-Enter': 'insertLineBefore',
                    'Backspace': 'smartBackspace',

                    "Shift-Cmd-Backspace": "delLineLeft",
                    "Shift-Cmd-Delete": "delLineRight",
                    "Cmd-Alt-Up": "addCursorToPrevLine",
                    "Cmd-Alt-Down": "addCursorToNextLine",
                }
                /* eslint-enable */
            })
            mtime = data.mtime
        })

        // Step 3: Do the rest of things (about 20 ms)
        initializeCM.then(() => schedule(() => {
            cm.refresh() // prevent CM occasionally shifts to the right
//            __this.completionProvider = new CompletionProvider(this)
            // only enable completionProvider when the document is a Python file
//            if (mode && mode.mode !== 'python') {
//                __this.completionProvider.enabled = false
//            }
//            __this.realtimeFormatter = RealtimeFormatter(this, CodeMirror)
//            __this.cmEventDispatcher = new CMEventDispatcher(this)
//            __this.completion.bindReferences(this)

            // resolve Safari over-scroll jitter issue
            const scroller = codeEditor.getElementsByClassName('CodeMirror-scroll')[0]
            scroller.onwheel = e => {
                if (e.deltaY <= 0) return
                const scrollInfo = __this.cm.getScrollInfo()
                if (scrollInfo.top + scrollInfo.clientHeight >= scrollInfo.height) {
                    e.preventDefault()
                }
            }
            if (__this.cmReadyCallback) {
                __this.cmReadyCallback(this)
                __this.cmReadyCallback = null
            }

            schedule(() => {
//                __this.outline = g.outline.generateOutline(__this.cm)
//                if (g.activeEditor === this)
//                    g.outline.set({ outlineItems: __this.outline })
            })
        }))
    })

    onDestroy(() => {
//        __this.tab.destroy()
//        g.linter.clear()
//        delete g.panelMiddle.pathToEditor[joinPath(__this.get().filePath)]
        __this.session.send('Close')
        __this.session.close()
    })

    // [svelte-upgrade warning]
    // beforeUpdate and afterUpdate handlers behave
    // differently to their v2 counterparts
    beforeUpdate(() => {
//        if (!previous) return
//        if (changed.filePath) {
//            const newPath = current.filePath
//            g.panelMiddle.pathToEditor[joinPath(newPath)] = this
//            if (previous.filePath) {
//                delete g.panelMiddle.pathToEditor[joinPath(previous.filePath)]
//                __this.session.send('Mtime', { newPath })
//            }
//        }
//        const tab = __this.tab
//        if (!tab) return
//
//        if (changed.fileName) {
//            tab.set({ name: current.fileName })
//        }
//        if (changed.clean) {
//            tab.set({ clean: current.clean })
//        }
//        if (changed.active) {
//            const { active } = current
//            const { cm } = this
//            tab.set({ active: active })
//            if (active && __this.session && cm) {
//                nextFrame(() => {
//                    // content may not show for background editors if multiple editors are opened during startup
//                    cm.refresh()
//                    __this.session.send('ActivateEditor')
//                })
//
//            }
//        }
//        if (changed.highlightOverlay) {
//            const { cm } = this
//            cm.removeOverlay(previous.highlightOverlay)
//            if (current.highlightOverlay && !cm.hasFocus()) {
//                cm.setOption('highlightSelectionMatches', false) // pause highlightSelectionMatches
//                cm.addOverlay(current.highlightOverlay, overlayOption)
//            } else { // resume highlightSelectionMatches
//                const currentOption = cm.getOption('highlightSelectionMatches')
//                if (__this.highlightSelectionMatches !== currentOption)
//                    cm.setOption('highlightSelectionMatches', __this.highlightSelectionMatches)
//            }
//        }
//        if (changed.textMark && previous.textMark) {
//            previous.textMark.clear()
//        }
    })

    export let isMakefile
    $: isMakefile = fileName.toLowerCase() === 'makefile'

    // [svelte-upgrade suggestion]
    // review these functions and remove unnecessary 'export' keywords
    export function save() {
        __this.saving = true
        __this.session.send('SaveFile', { content: __this.cm.getValue() })
        // preserve cursor and viewport position in case formatter changes the content
        __this.cursorBeforeSaving = __this.cm.getCursor()
        __this.scrollInfoBeforeSaving = __this.cm.getScrollInfo()
    }

    export function insertText(text) {
        g.activeEditor && g.activeEditor.cm.hasFocus()
        if (g.activeEditor != this || !__this.cm.hasFocus()) return
        __this.cm.doc.replaceRange(text, __this.cm.doc.getCursor('from'), __this.cm.doc.getCursor('to'), '+input')
    }

    export function markClean() {
        clean = true
        __this.cm.doc.markClean()
    }

    export function syncChanges(changes, lineContent) {
        if (!__this.completionProvider.enabled) return
        const { cm } = this
        if (!lineContent)
            for (let c = 0; c < changes.length; c++) {
                const change = changes[c]
                const { text, removed } = change
                const from = change.from.line
                const to = change.to.line

                let lint = text.length > 1 || removed.length > 1
                if (c != changes.length - 1) lint = false // only lint on last change

                text[0] = cm.getLine(from)
                if (to != from && to - from === text.length - 1)
                    text[text.length - 1] = cm.getLine(to)

                __this.session.send('SyncRange', [from, to + 1, lint, ...text])
            }
        else {
            __this.session.send('SyncRange', [changes, changes + 1, true, lineContent])
        }
        schedule(() => {
            __this.outline = g.outline.generateOutline(__this.cm)
            if (g.activeEditor === this)
                g.outline.set({
                    outlineItems: __this.outline,
                    currentLine: __this.cm.getCursor().line
                })
        })
    }
</script>
